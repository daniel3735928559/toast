Most recent updates at end...

20090316:120950:Where have we got to thus far? 

We have booting completed, which loads a pre-defined extent of blocks from the
floppy into RAM which are understood to contain the kernel, and jumps there
after initializing the video mode to something pre-determined.

Then we initialize paging and the kernel heap, which is a blob of code for
which I have partially forgotten the inner workings but which is not quite
correct--I need to identity-map more frames than I ought to get things working
at the moment (and thus set the heap further along).  I do not understand
this, and will go back and write up a more thorough description of what
happened there (as well as of the details of how this code works (despite that
most of it should be rather standard).

For now, though, we'll bash on regardless, as there is a workaround (namely,
ID-map a whole bunch of RAM until it works), which is terrible, but unlikely
to interfere with anything later on.

123256

===============================================================================

20090325:180200:PCI Enumeration

A random interlude in all the initrd/vfs programming that's bogged me down the
last week: PCI enumeration!  

We've got PCI devices enumerated on bus 0 only.  (Enumerating for slot all the
way up to 65536 or for higher busses seems to triple-fault.  Will investigate
more in the future, but for now we see everything necessary by getting things
only from bus 0 and only up to slot 100.)  The output is given as: 

BUS     SLOT    VID     DID     HTYPE   BAR0    BAR1    BAR2    BAR3    BAR4	BAR5
0	0	1106	3099	0	8	0	0	0	0	0
0	1	1106	B099	1	0	0	100	D0D0	F700	F7F0
0	5	13F6	111	0	B801	0	0	0	0	0
0	D	10EC	8029	0	B401	0	0	0	0	0
0	E	100B	20	0	B001	0	0	0	0	0
0	F	10B7	9055	0	A801	0	0	0	0	0
0	10	10EC	8139	0	A401	0	0	0	0	0
0	11	1106	3074	80	0	0	0	0	0	0
0	20	1002	5046	0	8	D801	0	0	0	0

Also, I've had to resort to manually (with a screwdriver) shorting two of the
pins on the motherboard to switch the computer on.  (Memo to my future self:
it's the fifth pair from the back).  Naturally, I'd like to be able to reset
it like this too (rather than having to unplug/replug the whole thing) but
shorting other random pairs of pins only gets some scary beeps and some
sparks.  Maybe some day I'll look it up properly, but for now, we'll play it
safe and use the mains-switch on the wall.

Now we'll fill some structs with the relevant data and parse it for the cases
when it'll be meaningful (namely, 3Com 3c905x, RTL8029, RTL8139).  The
relevant sections of the PCI vendor/device database are reproduced here
(verbatim) as a memo to my future self:

"0x10B7","0x9050","3Com Corporation","3C905B - Combo","Fast Etherlink XL PCI 10/100"
"0x10B7","0x9051","3Com Corporation","3C905-T4","Fast Etherlink XL 10/100"
"0x10B7","0x9055","3Com Corporation","3C905-TX","Fast Etherlink 10/100 PCI TX NIC"
"0x10B7","0x9056","3Com Corporation","3C905B-T4","Fast EtherLink XL 10/100"
"0x10B7","0x9058","3Com Corporation","3C905B-COMBO","Deluxe EtherLink 10/100 PCI Combo NIC"
"0x10B7","0x905A","3Com Corporation","3C905B-FX","Fast EtherLink 100 Fiber NIC"
"0x10B7","0x9200","3Com Corporation","3C905 CX-TX-M","Fast EtherLink for PCManagement NIC"

"0x10EC","0x0139","Realtek Semiconductor","rtl8139B","ethernet 10/100"
"0x10EC","0x0139_","Realtek Semiconductor","rtl8139B","ethernet 10/100"
"0x10EC","0x8021","Realtek Semiconductor","RTL8029AS","NIC"
"0x10EC","0x8029","Realtek Semiconductor","RTL8029(as)pci ethernet nic","windot XPse"
"0x10EC","0x8129","Realtek Semiconductor","RTL8139d","10/100 Fast Ethernet Controller"
"0x10EC","0x8138","Realtek Semiconductor","RT8139B/C","CardBus Fast Ethernet Adapter"
"0x10EC","0x8139","Realtek Semiconductor","RTL-8139/8139C/8139C","Realtek RTL8139 Family PCI Fast Ethernet NIC"

Because we're particularly eager, we'll go ahead and get sending with the
RTL8029AS.  Upon completion, better organization will be sorted out and such.  

Inspection of the ne2k-pci Linux module seems to indicate that the IO space
based at io_base = (BAR0 & 0xFFE0) (0xB400 in the above example) is not
memory-mapped, but rather in actual IO space (i.e. refers to a set of IO ports
reserved for the card by the BIOS at boot time).  

The best understanding I have of the spec at the moment is the following: The
card registers proper (not the ones in PCI config land that are seen above)
are accessed by reading as inb(io_base + offset) where 0 <= offset <= 0x0F.
However, there are 64 one-byte registers available, each in 16-byte `pages'
(as the spec calls them).  But you see that we are only given a range of 16
bytes to access in IO space, so this looks infeasible at first.  However, the
means they give for accessing the further registers is by writing a `page
number' (0 through 3) to the high two bits of the command register (always
found at io_base + 0x00).  This will select a current page of registers that
will be read/written by all future accesses until a new page is selected.  

So for example, if you write outb(io_base, inb(io_base) & 10111111b)
(i.e. select page 2), then reading inb(io_base + 0x01) will give out the value
of PSTART.

I'll short-hand the writing of registers to write(REG_NAME, value).  

235000

===============================================================================

20090326:130000:More RTL8029 bashing and multitasking stuff

Wrote skeleton RTL8029 initize and send routines according to RTL8029AS.pdf.

Now going back to to multitasking and initrd things after dinner.  

It's as yet a bit unclear how useful the initrd/vfs structure will be.  Rather
than have a file-system as a built-in paradigm, it seems better to just load a
block of starter nodes (which will include network drivers and hard disk
drivers and floppy drivers, of course, for loading anything else that might be
needed for initialization).  This amounts to essentially just throwing the VFS
out of kernel-land and sticking with a simplified concept of initrd, which is
nice and easy to implemenent.  

Naturally, the boot process can be logged and the initrd updated with whatever
is found to have been needed in the early stages of initialization, but that's
a separate matter.  

235800

===============================================================================

20090327:230514:Updates and stuff

RTL8029 initization routine doesn't seem to kill anything, but whether I can
send stuff and suchlike remains untested.  

Initrd code done and debugged (compiler-side, anyways), except I need to work
out how to get the ramdisk actually into memory (all ways readily found online
involve GRUB) and make sure that my rdgen makes an image that is actually
compatable (I forget!).  I'll worry about all that in due course, but what I'd
like to run through now is multitasking and IPC, which should be the last
(major) kernel thing to implement before we'll get to writing a proper IPC
protocol layer, and then proper drivers and a GUI.

Multitasking should be set up as follows: There is a linked-list of task
structures, each storing it's state (essentially, *all* registers) as well as
IPC-related information (the node_t struct in the documentation--basically an
indicator of where is it topologically (to what address space on what
computer) and what connections it has in place.  

The actual mechanics of task-loading and switching should really be very
simple: For loading, an address space is created and some kind of executable
parser runs on a designated file and sticks the appropriate bits into memory
as appropriate and then runs the task.  For switching, all we should need to
do is load all regs and jump to the appropriate stored eip.  

The problem is that this deals in tasks rather than in `nodes' (which is a
silly distinction, but I'll not quote it to downplay it in the future, as this
would get annoying).  So in the future, some notion should be built into the
kernel of what sort of thing it is meant to be loading into what address space
on what computer and suchlike.  The simplest way of doing this for now might
be to have the syscalls load(u32 nodeID), load_to(u32 nodeID, u32 loaction)
where location defines the address space and the computer (on x86
machines--where there are different abstractions, this may mean something else
(although the `which computer' distinction should always be meaningful)).  

So we'll implement this for now, get the ramdisk running and stick in it some
assembly programs that syscall to print out things.  Oh yeah.  Need to get
syscalls working too.  Pretty important, that.  Kind of obnoxious how these
last three things all need to be at least somewhat functional before they can
be properly tested.  At least before multitasking can be properly tested.  


Oh well.  The day they are done will be a good day.  

Out.  

233209

===============================================================================

20090328:023720:Hacky-Stack

In all recent endeavors, I've put off dealing with this one issue for about as
long as is possible, but now it's time to take it on in full.  Namely: Where
is the stack supposed to be at any given time and where is it at the outset?
When I've enabled paging, things don't instantly die, so I assume the stack is
in ID-mapped memory somewhere (which is probably at the root of that `I've
gotta ID-map more than I should have to' issue mentioned earlier), but that's
really all I know.  When I go to a different address space, that needs a stack
and where do I put that?  And when I syscall the kernel and want to call
functions from the handler that needs a stack and where do I put that?  All
these things I'd like to put to rest here and now once and for all.  

For non-kernel processes, the stack should always be in some well-defined,
fixed location in virtual memory, say 0, (sitting inside some arbitrary frame
or something--doesn't really matter).  When preparing an address space for a
new such processes, we'll just grab a free frame and stick the stack on it and
map it to that fixed location.  Sorted.

For the kernel, the stack should also be in some different fixed location.  It
should be different because the kernel is also mapped into the processes
address space at the same time, so unless we want to mess with page-tables
every time there's a syscall that wouldn't otherwise involve a context-switch,
it's best to have the stack be somewhere else.  Let's say we put it at
0xE0000000.  

(For security in the future, it might be handy to have an forcedly non-present
page below the stack always so that reads beyond the stack generate a
page-fault, which, if traced to the relevant page, can be reported as a `stack
overflow'.)

Now there's a fiddly bit.  When we execute a syscall, we'll be thrust back
into the kernel with our stack loaded from the TSS (some x86 silliness).  But
if we're then interrupted again and then again thrust into kernel-land by a
separate syscall before the previous one had finished, we could, if not
careful, end up trashing that stack.  So for each task we'll want a separate
stack for use in kernel-land, and when we switch to that task, we'll switch
the TSS's stack pointer to the corresponding kernel-stack (so if it syscalls,
the kernel will use the correct stack).  This does mean that in kernel-space,
we need a stack allocated for each running task.  Pain.  But it can be done.
Later.  

030621

===============================================================================

20090328:031031:Multitasking and IPC again

I'd like to clarify this again, because I've been referring throughout to the
notion of a task when officially, there is no such notion.  

SCHEDULER: 

The scheduler has a list of active nodes and, for now, switches between them
in a simple rota.  This works independent of address space, but each behaves
like it's in its own address space (has its own stack and whatnot).  

LOADER: 

The loader is told where to load a given node and the only difference between
loading to a new address space and to an existing one is whether a new heap
needs to be made and whether there's any dynamic linking to do.  

Flowchart: 

 START
   |
   |                           No
 Target address space exists? ----> Make it
   |                                  |
   | Yes                              |
   |                                  v
   |                               Make heap
   |                                  |
   |                                  |
   |                                  v
   |               Find valid place in address space for code
   |                                  |
   |                                  v             Yes
   +---------------------> Needs dynamic linking? ------> Link
                                      |                    |
                                      | No                 |
                                      v                    |
                            Make kernel stack  <-----------+
                                      |
				      v
              Load code and set up task struct, node struct, and TSS

040141

===============================================================================

20090328:041651:Ramdisk again

A possible solution to the `where is the ramdisk?' problem: Essentially, stick
it on the disk image in the manner of a very simplistic filesystem: Have the
linker stick it at some known address and load it there, later mapping those
frames to some fixed spot in virtual memory out of the way.

Actually, the difficulty had in doing this illustrates a problem: What does
physical RAM look like after loading all the kernel and after setting up the
heap but before enabling paging?  This is a useful question, because we need
to know where we are allowed to put things that actually depend on location in
physical RAM, e.g. DMA buffers and the ramdisk.

As it stands now: 

Kernel: 0x7C00 - 0x7C00 + kernel_size
Initial stack: ??? (will stick in prints lines to work it out)
Heap: ??? (Forgot)
Ramdisk: Nowhere
VESA memory: 0xF8000000-0xFFFFFFFF

When we enable paging, virtual memory looks like: 

ID-mapped: 0 - 0x7C00 + kernel_size
Kernel: 0x7C00 - 0x7C00 + kernel_size
Initial Stack: ??? (Same as above--Should move to pre-defined location)
Heap: ??? (Forgot)
Ramdisk: Nowhere (should move to some other pre-defined location)

Not so good.  Let's get a few of these numbers, shall we?  

042401

===============================================================================

20090328:124832:Ramdisk and stack solutions, Part I

For the Ramdisk, a nasty put completely workable solution presents itself:
Reserve a chunk in kinit.asm full of zeros, where we'll dd in the ramdisk
image after linking (but before cat with boot.bin), and whose address we'll
pass to kmain().  

Output of 

  u32 espv;
  asm volatile("mov %%esp, %0": "=r"(espv));
  prints("esp: ");print_hex_32(espv);prints("\n");
  prints("vidstart: ");print_hex_32(vidstart);prints("\n");

is 

   esp: 8FFDC
   vidstart: F8000000

Should be fine, but would be nice to stick it somewhere fixed and safer.  Say
we just map it to 0xC0002000 in virtual memory and permanently mark as
non-present the page 0xC0000000-0xC0001000 (for stack-overflow detection).  

If in kernel-space we always have allocated one stack-frame per node, then
it's just a matter of bookkeeping to store all these and adjust TSS->esp0 as
needed.  But this raises the question of how do we allocate these?  Because
userland doesn't get to use these stacks, let's pre-map some frames to the
area from, say, 0xC0002000 to 0xC0080000 (which should be the kernel start
when we get to higher-halfizing) treated as an array of 0x200-byte chunks with
tests as needed to make sure we've not got too much on the stack at any given
time.  So we'll always have a new kernel-stack available (we'll have to
maintain in the kernel heap a separate stack of which of these are free, which
is nasty but also doable).  

To the plan to organize virtual memory will be implemented as follows: 

HIGHER-HALFIZING: 

Loader blob 1: 
       -512-byte bootloader.  
       -Loaded at 0x7C00
       -Loads `Loader blob 2' (next 2 sectors on disk) to RAM at 0xA000.  
       -Loads ramdisk (next 20 sectors on disk) to RAM at 0x60000
       -Loads kernel proper to RAM at 0x10000
       -Passes control to loader blob 2.  

Loader blob 2: 
       -1024-byte stage2 bootloader.  
       -Loaded and linked at 0xA000.  
       -Set up VESA mode.
       -Switch to pmode (set up gdt and cr0 and flush)
       -Set stack at 0x8E000-0x8FFFF.  
       -Set up paging structures at 0x90000-0x92FFF
       -ID-map first 256 frames
       -Map stack to 0xC0001000-0xC0002000
       -Map ramdisk to 0xC0FFD000-0xC1000000
       -Map kernel (0x10000-kernel_end) to 0xC8000000-new_kernel_end)
       -Map page tables and pagedir upstairs compatably with the kernel defns
       -ID-Map screen area (0xF8000000-screen_end)
       -Enable paging
       -Set esp, ebp to 0xC0002000
       (Copy VESA mode info block to just before kernel)
       -Jump to kernel, passing along 
       	     -vidmem start pointer
	     -page_dir pointer
	     -ramdisk start pointer

Kernel: 
	-Loaded at 0x10000 in physical RAM, linked at 0xC8000000
	Store info passed from stage2: 
		Ramdisk start
		Vidmem start
	And initialize paging imap by analyzing what's been mapped already

	Will use physical RAM from above 0x10000 for PD and PT structures.  
	Will use virtual RAM from 0xC0002000-0xC6FFFFFF for kernel structs.
	Kernel structures: 
	   PTs and PDs
	   Threads
	   Nodes
	   Connections
	   Kernel Stacks (for reentrancy)
	Multiasking: 
	   Task struct: 
	      UID
	      kstack_index
	      esp
	      ebp
	      eip
	      page_dir
	      regs
	      next_task
	   Loading task: 
	      Work out where to put it
	      Make a new stack
	      Make a new PD, mapping in the kernel and the new stack
	   Switching tasks: 
	      Save current task data
	      Load new task's data
	IPC: 
	   To work out later.  

So that's the plan for what will hopefully be the final rewrite of the
initization code.  Lez go!  

165742

20090329:193933:Getting there

-'d elements in the todo list for higher-halfizing are done on this side of
 the compiling/debugging process.  We'll get to testing and stuff tomorrow
 after digging up those dump PTEs routines from a while ago.  

In the interim, a brief rundown: Kernel loader stage 1 loads everything from
disk to RAM in pre-defined locations that stage2 knows about.  

Stage 2 has an asm bit that enables paging but calls a C bit (stage2c.c) to do
the dirty work of page-mapping (being careful to make sure the PD and PTs are
mapped into virtual memory as well!) to ensure that it uses the main kernel's
structures for storing at least the pagedir.

The kernel can collect all the information it needs from the pagedir
structure, as it contains the physical address of the PD (for cr3), the
physical addresses of the page tables (for [cr3]), and the virtual addresses
of the page tables (for its own reference).  From this latter array it can
read off where the tables are in its structure area (our informal name for the
range 0xC0000000-0xC1000000, where the stack and other kernel structures will
live), and thus, assuming these (and the ramdisk) are the only things that
were set up (and they were), it can build a complete picture of what the
address spaces (physical and virtual) look like.  More specifically, by
looking at the page table it can work out what frames are used and brutally
set the corresponding bits in the physmem imap, force it to reset its stack,
and then we'll be all set to allocate as before.  

Of course, then we have to be careful about how we organize the structure area
for storing all the things, as we don't have a heap to dump everything in
anymore (by the way, statically allocating kernel structures versus leaving
them all in a heap was a design decision made while researching higher0half
kernels: With a microkernel there are a very much pre-defined set of things
the kernel will need to manage, which it can then do with simple array-type
managers (with imaps, much like the mage allocater, actually) for each of the
six or so things that need managing, and that's it.  A bit more complex, but
no nasty bintree lookups clogging the IPC routines, at least.  

OK, sleep time.  

195213


20090330:133825:More hh fun--GDT mapping

A question: Do we need to use the GDT ever after setting up the IDT/ISRs?
Also, do the IDT/ISRs need to be mapped into virtual address space?  Probably,
since they'll be running and stuff.  Hmm...

142000

20090330:221308:I might actually be that stupid

There is a naive approach to higher-halfizing, that, while I thought of at the
outset, might just work verbatim.  The method there would be to have stage1
load everything to RAM as before, including a stage2 as in the rather
complicated plan described above, but then rather than thinking about what
needs to be mapped where, just have the kernel/ramdisk/whatever loaded at
0x100000 by stage1, go into protected mode with a GDT and whatnot, and then
ID-map the first huge and translate-map the kernel stuff to 0xC0100000, jump
there and away you go.

Sounds nice and all, but the problem I perceived as eliminating this as a
viable option was that 
1. You'd still rely on structures from inside the low memory, which causes
   problems if any hardware is mapped there
2. You'd have the page-tables both tortuously set up manually to comply with
   the structs they'll be stored in during the C code bits and sitting (again)
   in low memory, possibly causing unknown problems.  

However, we can just re-setup the page-tables and the GDT when we jump
upstairs and re-load them all and be perfectly happy.  What's more, we can
wait until we get upstairs to set up the IDT/ISRs at all, so after a little
bit of setup, we'll be free of the downstairs constructions completely.
Hurrah.  

Let's have a go at that through the night and see where we are at the end of
it.  After that, we can get to testing ramdisk code and writing at least
syscall code, leaving little else to be done.  

Lez go.  

225421

20090331:013234:Going...

Well, in its current state the page-table setup downstairs seems to work
fine.  Just can't jump upstairs just yet.  We'll see...  

Also, VESA doesn't seem to be initialized properly.  What?  

Will look at it more after some sleep.  

013557

20090331:122237

Turns out the page table doesn't work just fine (was 'jmp $'ing before it got
there), but now VESA works OK, just need to debug the page tables and such.
Endianness problem is suspected.  

122338

20090331:170037:I'm an idiot II

The $64,000 question is: True or false.  0x8E00 is divisible by 0x1000.  

Me: True!

!?!???!!?!??!

Paging works now.  Note to future self: align 0x1000 in the asm does alignment
at assembly time, so if you then link at 0x7E00, say, it's not gonna be 4K
aligned in RAM!  

Now let's see if that jumping business works.  

TRIPLE FAULT!

There was that whole `lea' deal.  We now look into that...

Got bochs running.  It says the problem is that the page for 0xC010000 is not
present.  I have a bad record with these page-mapping deals.  We'll see what
idiocy has given rise to this latest waste of many hours...

200846

20090331:223038:QEMU+GDB

I've now, after a bit of Googling and fiddling with Bochs to try to get

     ./configure --enable-debugger --enable-disasm 

to work (fails with gtk+-2.0 not found), got QEMU working and, by using: 

   qemu /dev/sdb -boot a -fda /dev/sdb -s -S

can get into it with gdb by running 

    target remote :1234 

inside gdb.  

Before we enable paging, this is the pagedir: 

x/1024w 0xA000

0xa000: 0x0000b003      0x00000000      0x00000000      0x00000000
0xa010: 0x00000000      0x00000000      0x00000000      0x00000000
0xa020: 0x00000000      0x00000000      0x00000000      0x00000000
0xa030: 0x00000000      0x00000000      0x00000000      0x00000000
0xa040: 0x00000000      0x00000000      0x00000000      0x00000000
0xa050: 0x00000000      0x00000000      0x00000000      0x00000000
0xa060: 0x00000000      0x00000000      0x00000000      0x00000000
0xa070: 0x00000000      0x00000000      0x00000000      0x00000000
0xa080: 0x00000000      0x00000000      0x00000000      0x00000000
0xa090: 0x00000000      0x00000000      0x00000000      0x00000000
0xa0a0: 0x00000000      0x00000000      0x00000000      0x00000000
0xa0b0: 0x00000000      0x00000000      0x00000000      0x00000000
0xa0c0: 0x00000000      0x00000000      0x00000000      0x00000000
0xa0d0: 0x00000000      0x00000000      0x00000000      0x00000000
0xa0e0: 0x00000000      0x00000000      0x00000000      0x00000000
0xa0f0: 0x00000000      0x00000000      0x00000000      0x00000000
0xa100: 0x00000000      0x00000000      0x00000000      0x00000000
0xa110: 0x00000000      0x00000000      0x00000000      0x00000000
0xa120: 0x00000000      0x00000000      0x00000000      0x00000000
0xa130: 0x00000000      0x00000000      0x00000000      0x00000000
0xa140: 0x00000000      0x00000000      0x00000000      0x00000000
0xa150: 0x00000000      0x00000000      0x00000000      0x00000000
0xa160: 0x00000000      0x00000000      0x00000000      0x00000000
0xa170: 0x00000000      0x00000000      0x00000000      0x00000000
0xa180: 0x00000000      0x00000000      0x00000000      0x00000000
0xa190: 0x00000000      0x00000000      0x00000000      0x00000000
0xa1a0: 0x00000000      0x00000000      0x00000000      0x00000000
0xa1b0: 0x00000000      0x00000000      0x00000000      0x00000000
0xa1c0: 0x00000000      0x00000000      0x00000000      0x00000000
0xa1d0: 0x00000000      0x00000000      0x00000000      0x00000000
0xa1e0: 0x00000000      0x00000000      0x00000000      0x00000000
0xa1f0: 0x00000000      0x00000000      0x00000000      0x00000000
0xa200: 0x00000000      0x00000000      0x00000000      0x00000000
0xa210: 0x00000000      0x00000000      0x00000000      0x00000000
0xa220: 0x00000000      0x00000000      0x00000000      0x00000000
0xa230: 0x00000000      0x00000000      0x00000000      0x00000000
0xa240: 0x00000000      0x00000000      0x00000000      0x00000000
0xa250: 0x00000000      0x00000000      0x00000000      0x00000000
0xa260: 0x00000000      0x00000000      0x00000000      0x00000000
0xa270: 0x00000000      0x00000000      0x00000000      0x00000000
0xa280: 0x00000000      0x00000000      0x00000000      0x00000000
0xa290: 0x00000000      0x00000000      0x00000000      0x00000000
0xa2a0: 0x00000000      0x00000000      0x00000000      0x00000000
0xa2b0: 0x00000000      0x00000000      0x00000000      0x00000000
0xa2c0: 0x00000000      0x00000000      0x00000000      0x00000000
0xa2d0: 0x00000000      0x00000000      0x00000000      0x00000000
0xa2e0: 0x00000000      0x00000000      0x00000000      0x00000000
0xa2f0: 0x00000000      0x00000000      0x00000000      0x00000000
0xa300: 0x0000c003      0x00000000      0x00000000      0x00000000
0xa310: 0x00000000      0x00000000      0x00000000      0x00000000
0xa320: 0x00000000      0x00000000      0x00000000      0x00000000
0xa330: 0x00000000      0x00000000      0x00000000      0x00000000
0xa340: 0x00000000      0x00000000      0x00000000      0x00000000
0xa350: 0x00000000      0x00000000      0x00000000      0x00000000
0xa360: 0x00000000      0x00000000      0x00000000      0x00000000
0xa370: 0x00000000      0x00000000      0x00000000      0x00000000
0xa380: 0x00000000      0x00000000      0x00000000      0x00000000
0xa390: 0x00000000      0x00000000      0x00000000      0x00000000
0xa3a0: 0x00000000      0x00000000      0x00000000      0x00000000
0xa3b0: 0x00000000      0x00000000      0x00000000      0x00000000
0xa3c0: 0x00000000      0x00000000      0x00000000      0x00000000
0xa3d0: 0x00000000      0x00000000      0x00000000      0x00000000
0xa3e0: 0x00000000      0x00000000      0x00000000      0x00000000
0xa3f0: 0x00000000      0x00000000      0x00000000      0x00000000
0xa400: 0x00000000      0x00000000      0x00000000      0x00000000
0xa410: 0x00000000      0x00000000      0x00000000      0x00000000
0xa420: 0x00000000      0x00000000      0x00000000      0x00000000
0xa430: 0x00000000      0x00000000      0x00000000      0x00000000
0xa440: 0x00000000      0x00000000      0x00000000      0x00000000
0xa450: 0x00000000      0x00000000      0x00000000      0x00000000
0xa460: 0x00000000      0x00000000      0x00000000      0x00000000
0xa470: 0x00000000      0x00000000      0x00000000      0x00000000
0xa480: 0x00000000      0x00000000      0x00000000      0x00000000
0xa490: 0x00000000      0x00000000      0x00000000      0x00000000
0xa4a0: 0x00000000      0x00000000      0x00000000      0x00000000
0xa4b0: 0x00000000      0x00000000      0x00000000      0x00000000
0xa4c0: 0x00000000      0x00000000      0x00000000      0x00000000
0xa4d0: 0x00000000      0x00000000      0x00000000      0x00000000
0xa4e0: 0x00000000      0x00000000      0x00000000      0x00000000
0xa4f0: 0x00000000      0x00000000      0x00000000      0x00000000
0xa500: 0x00000000      0x00000000      0x00000000      0x00000000
0xa510: 0x00000000      0x00000000      0x00000000      0x00000000
0xa520: 0x00000000      0x00000000      0x00000000      0x00000000
0xa530: 0x00000000      0x00000000      0x00000000      0x00000000
0xa540: 0x00000000      0x00000000      0x00000000      0x00000000
0xa550: 0x00000000      0x00000000      0x00000000      0x00000000
0xa560: 0x00000000      0x00000000      0x00000000      0x00000000
0xa570: 0x00000000      0x00000000      0x00000000      0x00000000
0xa580: 0x00000000      0x00000000      0x00000000      0x00000000
0xa590: 0x00000000      0x00000000      0x00000000      0x00000000
0xa5a0: 0x00000000      0x00000000      0x00000000      0x00000000
0xa5b0: 0x00000000      0x00000000      0x00000000      0x00000000
0xa5c0: 0x00000000      0x00000000      0x00000000      0x00000000
0xa5d0: 0x00000000      0x00000000      0x00000000      0x00000000
0xa5e0: 0x00000000      0x00000000      0x00000000      0x00000000
0xa5f0: 0x00000000      0x00000000      0x00000000      0x00000000
0xa600: 0x00000000      0x00000000      0x00000000      0x00000000
0xa610: 0x00000000      0x00000000      0x00000000      0x00000000
0xa620: 0x00000000      0x00000000      0x00000000      0x00000000
0xa630: 0x00000000      0x00000000      0x00000000      0x00000000
0xa640: 0x00000000      0x00000000      0x00000000      0x00000000
0xa650: 0x00000000      0x00000000      0x00000000      0x00000000
0xa660: 0x00000000      0x00000000      0x00000000      0x00000000
0xa670: 0x00000000      0x00000000      0x00000000      0x00000000
0xa680: 0x00000000      0x00000000      0x00000000      0x00000000
0xa690: 0x00000000      0x00000000      0x00000000      0x00000000
0xa6a0: 0x00000000      0x00000000      0x00000000      0x00000000
0xa6b0: 0x00000000      0x00000000      0x00000000      0x00000000
0xa6c0: 0x00000000      0x00000000      0x00000000      0x00000000
0xa6d0: 0x00000000      0x00000000      0x00000000      0x00000000
0xa6e0: 0x00000000      0x00000000      0x00000000      0x00000000
0xa6f0: 0x00000000      0x00000000      0x00000000      0x00000000
0xa700: 0x00000000      0x00000000      0x00000000      0x00000000
0xa710: 0x00000000      0x00000000      0x00000000      0x00000000
0xa720: 0x00000000      0x00000000      0x00000000      0x00000000
0xa730: 0x00000000      0x00000000      0x00000000      0x00000000
0xa740: 0x00000000      0x00000000      0x00000000      0x00000000
0xa750: 0x00000000      0x00000000      0x00000000      0x00000000
0xa760: 0x00000000      0x00000000      0x00000000      0x00000000
0xa770: 0x00000000      0x00000000      0x00000000      0x00000000
0xa780: 0x00000000      0x00000000      0x00000000      0x00000000
0xa790: 0x00000000      0x00000000      0x00000000      0x00000000
0xa7a0: 0x00000000      0x00000000      0x00000000      0x00000000
0xa7b0: 0x00000000      0x00000000      0x00000000      0x00000000
0xa7c0: 0x00000000      0x00000000      0x00000000      0x00000000
0xa7d0: 0x00000000      0x00000000      0x00000000      0x00000000
0xa7e0: 0x00000000      0x00000000      0x00000000      0x00000000
0xa7f0: 0x00000000      0x00000000      0x00000000      0x00000000
0xa800: 0x00000000      0x00000000      0x00000000      0x00000000
0xa810: 0x00000000      0x00000000      0x00000000      0x00000000
0xa820: 0x00000000      0x00000000      0x00000000      0x00000000
0xa830: 0x00000000      0x00000000      0x00000000      0x00000000
0xa840: 0x00000000      0x00000000      0x00000000      0x00000000
0xa850: 0x00000000      0x00000000      0x00000000      0x00000000
0xa860: 0x00000000      0x00000000      0x00000000      0x00000000
0xa870: 0x00000000      0x00000000      0x00000000      0x00000000
0xa880: 0x00000000      0x00000000      0x00000000      0x00000000
0xa890: 0x00000000      0x00000000      0x00000000      0x00000000
0xa8a0: 0x00000000      0x00000000      0x00000000      0x00000000
0xa8b0: 0x00000000      0x00000000      0x00000000      0x00000000
0xa8c0: 0x00000000      0x00000000      0x00000000      0x00000000
0xa8d0: 0x00000000      0x00000000      0x00000000      0x00000000
0xa8e0: 0x00000000      0x00000000      0x00000000      0x00000000
0xa8f0: 0x00000000      0x00000000      0x00000000      0x00000000
0xa900: 0x00000000      0x00000000      0x00000000      0x00000000
0xa910: 0x00000000      0x00000000      0x00000000      0x00000000
0xa920: 0x00000000      0x00000000      0x00000000      0x00000000
0xa930: 0x00000000      0x00000000      0x00000000      0x00000000
0xa940: 0x00000000      0x00000000      0x00000000      0x00000000
0xa950: 0x00000000      0x00000000      0x00000000      0x00000000
0xa960: 0x00000000      0x00000000      0x00000000      0x00000000
0xa970: 0x00000000      0x00000000      0x00000000      0x00000000
0xa980: 0x00000000      0x00000000      0x00000000      0x00000000
0xa990: 0x00000000      0x00000000      0x00000000      0x00000000
0xa9a0: 0x00000000      0x00000000      0x00000000      0x00000000
0xa9b0: 0x00000000      0x00000000      0x00000000      0x00000000
0xa9c0: 0x00000000      0x00000000      0x00000000      0x00000000
0xa9d0: 0x00000000      0x00000000      0x00000000      0x00000000
0xa9e0: 0x00000000      0x00000000      0x00000000      0x00000000
0xa9f0: 0x00000000      0x00000000      0x00000000      0x00000000
0xaa00: 0x00000000      0x00000000      0x00000000      0x00000000
0xaa10: 0x00000000      0x00000000      0x00000000      0x00000000
0xaa20: 0x00000000      0x00000000      0x00000000      0x00000000
0xaa30: 0x00000000      0x00000000      0x00000000      0x00000000
0xaa40: 0x00000000      0x00000000      0x00000000      0x00000000
0xaa50: 0x00000000      0x00000000      0x00000000      0x00000000
0xaa60: 0x00000000      0x00000000      0x00000000      0x00000000
0xaa70: 0x00000000      0x00000000      0x00000000      0x00000000
0xaa80: 0x00000000      0x00000000      0x00000000      0x00000000
0xaa90: 0x00000000      0x00000000      0x00000000      0x00000000
0xaaa0: 0x00000000      0x00000000      0x00000000      0x00000000
0xaab0: 0x00000000      0x00000000      0x00000000      0x00000000
0xaac0: 0x00000000      0x00000000      0x00000000      0x00000000
0xaad0: 0x00000000      0x00000000      0x00000000      0x00000000
0xaae0: 0x00000000      0x00000000      0x00000000      0x00000000
0xaaf0: 0x00000000      0x00000000      0x00000000      0x00000000
0xab00: 0x00000000      0x00000000      0x00000000      0x00000000
0xab10: 0x00000000      0x00000000      0x00000000      0x00000000
0xab20: 0x00000000      0x00000000      0x00000000      0x00000000
0xab30: 0x00000000      0x00000000      0x00000000      0x00000000
0xab40: 0x00000000      0x00000000      0x00000000      0x00000000
0xab50: 0x00000000      0x00000000      0x00000000      0x00000000
0xab60: 0x00000000      0x00000000      0x00000000      0x00000000
0xab70: 0x00000000      0x00000000      0x00000000      0x00000000
0xab80: 0x00000000      0x00000000      0x00000000      0x00000000
0xab90: 0x00000000      0x00000000      0x00000000      0x00000000
0xaba0: 0x00000000      0x00000000      0x00000000      0x00000000
0xabb0: 0x00000000      0x00000000      0x00000000      0x00000000
0xabc0: 0x00000000      0x00000000      0x00000000      0x00000000
0xabd0: 0x00000000      0x00000000      0x00000000      0x00000000
0xabe0: 0x00000000      0x00000000      0x00000000      0x00000000
0xabf0: 0x00000000      0x00000000      0x00000000      0x00000000
0xac00: 0x00000000      0x00000000      0x00000000      0x00000000
0xac10: 0x00000000      0x00000000      0x00000000      0x00000000
0xac20: 0x00000000      0x00000000      0x00000000      0x00000000
0xac30: 0x00000000      0x00000000      0x00000000      0x00000000
0xac40: 0x00000000      0x00000000      0x00000000      0x00000000
0xac50: 0x00000000      0x00000000      0x00000000      0x00000000
0xac60: 0x00000000      0x00000000      0x00000000      0x00000000
0xac70: 0x00000000      0x00000000      0x00000000      0x00000000
0xac80: 0x00000000      0x00000000      0x00000000      0x00000000
0xac90: 0x00000000      0x00000000      0x00000000      0x00000000
0xaca0: 0x00000000      0x00000000      0x00000000      0x00000000
0xacb0: 0x00000000      0x00000000      0x00000000      0x00000000
0xacc0: 0x00000000      0x00000000      0x00000000      0x00000000
0xacd0: 0x00000000      0x00000000      0x00000000      0x00000000
0xace0: 0x00000000      0x00000000      0x00000000      0x00000000
0xacf0: 0x00000000      0x00000000      0x00000000      0x00000000
0xad00: 0x00000000      0x00000000      0x00000000      0x00000000
0xad10: 0x00000000      0x00000000      0x00000000      0x00000000
0xad20: 0x00000000      0x00000000      0x00000000      0x00000000
0xad30: 0x00000000      0x00000000      0x00000000      0x00000000
0xad40: 0x00000000      0x00000000      0x00000000      0x00000000
0xad50: 0x00000000      0x00000000      0x00000000      0x00000000
0xad60: 0x00000000      0x00000000      0x00000000      0x00000000
0xad70: 0x00000000      0x00000000      0x00000000      0x00000000
0xad80: 0x00000000      0x00000000      0x00000000      0x00000000
0xad90: 0x00000000      0x00000000      0x00000000      0x00000000
0xada0: 0x00000000      0x00000000      0x00000000      0x00000000
0xadb0: 0x00000000      0x00000000      0x00000000      0x00000000
0xadc0: 0x00000000      0x00000000      0x00000000      0x00000000
0xadd0: 0x00000000      0x00000000      0x00000000      0x00000000
0xade0: 0x00000000      0x00000000      0x00000000      0x00000000
0xadf0: 0x00000000      0x00000000      0x00000000      0x00000000
0xae00: 0x00000000      0x00000000      0x00000000      0x00000000
0xae10: 0x00000000      0x00000000      0x00000000      0x00000000
0xae20: 0x00000000      0x00000000      0x00000000      0x00000000
0xae30: 0x00000000      0x00000000      0x00000000      0x00000000
0xae40: 0x00000000      0x00000000      0x00000000      0x00000000
0xae50: 0x00000000      0x00000000      0x00000000      0x00000000
0xae60: 0x00000000      0x00000000      0x00000000      0x00000000
0xae70: 0x00000000      0x00000000      0x00000000      0x00000000
0xae80: 0x00000000      0x00000000      0x00000000      0x00000000
0xae90: 0x00000000      0x00000000      0x00000000      0x00000000
0xaea0: 0x00000000      0x00000000      0x00000000      0x00000000
0xaeb0: 0x00000000      0x00000000      0x00000000      0x00000000
0xaec0: 0x00000000      0x00000000      0x00000000      0x00000000
0xaed0: 0x00000000      0x00000000      0x00000000      0x00000000
0xaee0: 0x00000000      0x00000000      0x00000000      0x00000000
0xaef0: 0x00000000      0x00000000      0x00000000      0x00000000
0xaf00: 0x00000000      0x00000000      0x00000000      0x00000000
0xaf10: 0x00000000      0x00000000      0x00000000      0x00000000
0xaf20: 0x00000000      0x00000000      0x00000000      0x00000000
0xaf30: 0x00000000      0x00000000      0x00000000      0x00000000
0xaf40: 0x00000000      0x00000000      0x00000000      0x00000000
0xaf50: 0x00000000      0x00000000      0x00000000      0x00000000
0xaf60: 0x00000000      0x00000000      0x00000000      0x00000000
0xaf70: 0x00000000      0x00000000      0x00000000      0x00000000
0xaf80: 0x00000000      0x00000000      0x00000000      0x00000000
0xaf90: 0x00000000      0x00000000      0x00000000      0x00000000
0xafa0: 0x00000000      0x00000000      0x00000000      0x00000000
0xafb0: 0x00000000      0x00000000      0x00000000      0x00000000
0xafc0: 0x00000000      0x00000000      0x00000000      0x00000000
0xafd0: 0x00000000      0x00000000      0x00000000      0x00000000
0xafe0: 0x00000000      0x00000000      0x00000000      0x00000000
0xaff0: 0x00000000      0x00000000      0x00000000      0x00000000

This is the pagetable at 0xb000: 

x/1024w 0xB000

0xb000: 0x00000003      0x00001003      0x00002003      0x00003003
0xb010: 0x00004003      0x00005003      0x00006003      0x00007003
0xb020: 0x00008003      0x00009003      0x0000a003      0x0000b003
0xb030: 0x0000c003      0x0000d003      0x0000e003      0x0000f003
0xb040: 0x00010003      0x00011003      0x00012003      0x00013003
0xb050: 0x00014003      0x00015003      0x00016003      0x00017003
0xb060: 0x00018003      0x00019003      0x0001a003      0x0001b003
0xb070: 0x0001c003      0x0001d003      0x0001e003      0x0001f003
0xb080: 0x00020003      0x00021003      0x00022003      0x00023003
0xb090: 0x00024003      0x00025003      0x00026003      0x00027003
0xb0a0: 0x00028003      0x00029003      0x0002a003      0x0002b003
0xb0b0: 0x0002c003      0x0002d003      0x0002e003      0x0002f003
0xb0c0: 0x00030003      0x00031003      0x00032003      0x00033003
0xb0d0: 0x00034003      0x00035003      0x00036003      0x00037003
0xb0e0: 0x00038003      0x00039003      0x0003a003      0x0003b003
0xb0f0: 0x0003c003      0x0003d003      0x0003e003      0x0003f003
0xb100: 0x00040003      0x00041003      0x00042003      0x00043003
0xb110: 0x00044003      0x00045003      0x00046003      0x00047003
0xb120: 0x00048003      0x00049003      0x0004a003      0x0004b003
0xb130: 0x0004c003      0x0004d003      0x0004e003      0x0004f003
0xb140: 0x00050003      0x00051003      0x00052003      0x00053003
0xb150: 0x00054003      0x00055003      0x00056003      0x00057003
0xb160: 0x00058003      0x00059003      0x0005a003      0x0005b003
0xb170: 0x0005c003      0x0005d003      0x0005e003      0x0005f003
0xb180: 0x00060003      0x00061003      0x00062003      0x00063003
0xb190: 0x00064003      0x00065003      0x00066003      0x00067003
0xb1a0: 0x00068003      0x00069003      0x0006a003      0x0006b003
0xb1b0: 0x0006c003      0x0006d003      0x0006e003      0x0006f003
0xb1c0: 0x00070003      0x00071003      0x00072003      0x00073003
0xb1d0: 0x00074003      0x00075003      0x00076003      0x00077003
0xb1e0: 0x00078003      0x00079003      0x0007a003      0x0007b003
0xb1f0: 0x0007c003      0x0007d003      0x0007e003      0x0007f003
0xb200: 0x00080003      0x00081003      0x00082003      0x00083003
0xb210: 0x00084003      0x00085003      0x00086003      0x00087003
0xb220: 0x00088003      0x00089003      0x0008a003      0x0008b003
0xb230: 0x0008c003      0x0008d003      0x0008e003      0x0008f003
0xb240: 0x00090003      0x00091003      0x00092003      0x00093003
0xb250: 0x00094003      0x00095003      0x00096003      0x00097003
0xb260: 0x00098003      0x00099003      0x0009a003      0x0009b003
0xb270: 0x0009c003      0x0009d003      0x0009e003      0x0009f003
0xb280: 0x000a0003      0x000a1003      0x000a2003      0x000a3003
0xb290: 0x000a4003      0x000a5003      0x000a6003      0x000a7003
0xb2a0: 0x000a8003      0x000a9003      0x000aa003      0x000ab003
0xb2b0: 0x000ac003      0x000ad003      0x000ae003      0x000af003
0xb2c0: 0x000b0003      0x000b1003      0x000b2003      0x000b3003
0xb2d0: 0x000b4003      0x000b5003      0x000b6003      0x000b7003
0xb2e0: 0x000b8003      0x000b9003      0x000ba003      0x000bb003
0xb2f0: 0x000bc003      0x000bd003      0x000be003      0x000bf003
0xb300: 0x000c0003      0x000c1003      0x000c2003      0x000c3003
0xb310: 0x000c4003      0x000c5003      0x000c6003      0x000c7003
0xb320: 0x000c8003      0x000c9003      0x000ca003      0x000cb003
0xb330: 0x000cc003      0x000cd003      0x000ce003      0x000cf003
0xb340: 0x000d0003      0x000d1003      0x000d2003      0x000d3003
0xb350: 0x000d4003      0x000d5003      0x000d6003      0x000d7003
0xb360: 0x000d8003      0x000d9003      0x000da003      0x000db003
0xb370: 0x000dc003      0x000dd003      0x000de003      0x000df003
0xb380: 0x000e0003      0x000e1003      0x000e2003      0x000e3003
0xb390: 0x000e4003      0x000e5003      0x000e6003      0x000e7003
0xb3a0: 0x000e8003      0x000e9003      0x000ea003      0x000eb003
0xb3b0: 0x000ec003      0x000ed003      0x000ee003      0x000ef003
0xb3c0: 0x000f0003      0x000f1003      0x000f2003      0x000f3003
0xb3d0: 0x000f4003      0x000f5003      0x000f6003      0x000f7003
0xb3e0: 0x000f8003      0x000f9003      0x000fa003      0x000fb003
0xb3f0: 0x000fc003      0x000fd003      0x000fe003      0x000ff003
0xb400: 0x00100003      0x00101003      0x00102003      0x00103003
0xb410: 0x00104003      0x00105003      0x00106003      0x00107003
0xb420: 0x00108003      0x00109003      0x0010a003      0x0010b003
0xb430: 0x0010c003      0x0010d003      0x0010e003      0x0010f003
0xb440: 0x00110003      0x00111003      0x00112003      0x00113003
0xb450: 0x00114003      0x00115003      0x00116003      0x00117003
0xb460: 0x00118003      0x00119003      0x0011a003      0x0011b003
0xb470: 0x0011c003      0x0011d003      0x0011e003      0x0011f003
0xb480: 0x00120003      0x00121003      0x00122003      0x00123003
0xb490: 0x00124003      0x00125003      0x00126003      0x00127003
0xb4a0: 0x00128003      0x00129003      0x0012a003      0x0012b003
0xb4b0: 0x0012c003      0x0012d003      0x0012e003      0x0012f003
0xb4c0: 0x00130003      0x00131003      0x00132003      0x00133003
0xb4d0: 0x00134003      0x00135003      0x00136003      0x00137003
0xb4e0: 0x00138003      0x00139003      0x0013a003      0x0013b003
0xb4f0: 0x0013c003      0x0013d003      0x0013e003      0x0013f003
0xb500: 0x00140003      0x00141003      0x00142003      0x00143003
0xb510: 0x00144003      0x00145003      0x00146003      0x00147003
0xb520: 0x00148003      0x00149003      0x0014a003      0x0014b003
0xb530: 0x0014c003      0x0014d003      0x0014e003      0x0014f003
0xb540: 0x00150003      0x00151003      0x00152003      0x00153003
0xb550: 0x00154003      0x00155003      0x00156003      0x00157003
0xb560: 0x00158003      0x00159003      0x0015a003      0x0015b003
0xb570: 0x0015c003      0x0015d003      0x0015e003      0x0015f003
0xb580: 0x00160003      0x00161003      0x00162003      0x00163003
0xb590: 0x00164003      0x00165003      0x00166003      0x00167003
0xb5a0: 0x00168003      0x00169003      0x0016a003      0x0016b003
0xb5b0: 0x0016c003      0x0016d003      0x0016e003      0x0016f003
0xb5c0: 0x00170003      0x00171003      0x00172003      0x00173003
0xb5d0: 0x00174003      0x00175003      0x00176003      0x00177003
0xb5e0: 0x00178003      0x00179003      0x0017a003      0x0017b003
0xb5f0: 0x0017c003      0x0017d003      0x0017e003      0x0017f003
0xb600: 0x00180003      0x00181003      0x00182003      0x00183003
0xb610: 0x00184003      0x00185003      0x00186003      0x00187003
0xb620: 0x00188003      0x00189003      0x0018a003      0x0018b003
0xb630: 0x0018c003      0x0018d003      0x0018e003      0x0018f003
0xb640: 0x00190003      0x00191003      0x00192003      0x00193003
0xb650: 0x00194003      0x00195003      0x00196003      0x00197003
0xb660: 0x00198003      0x00199003      0x0019a003      0x0019b003
0xb670: 0x0019c003      0x0019d003      0x0019e003      0x0019f003
0xb680: 0x001a0003      0x001a1003      0x001a2003      0x001a3003
0xb690: 0x001a4003      0x001a5003      0x001a6003      0x001a7003
0xb6a0: 0x001a8003      0x001a9003      0x001aa003      0x001ab003
0xb6b0: 0x001ac003      0x001ad003      0x001ae003      0x001af003
0xb6c0: 0x001b0003      0x001b1003      0x001b2003      0x001b3003
0xb6d0: 0x001b4003      0x001b5003      0x001b6003      0x001b7003
0xb6e0: 0x001b8003      0x001b9003      0x001ba003      0x001bb003
0xb6f0: 0x001bc003      0x001bd003      0x001be003      0x001bf003
0xb700: 0x001c0003      0x001c1003      0x001c2003      0x001c3003
0xb710: 0x001c4003      0x001c5003      0x001c6003      0x001c7003
0xb720: 0x001c8003      0x001c9003      0x001ca003      0x001cb003
0xb730: 0x001cc003      0x001cd003      0x001ce003      0x001cf003
0xb740: 0x001d0003      0x001d1003      0x001d2003      0x001d3003
0xb750: 0x001d4003      0x001d5003      0x001d6003      0x001d7003
0xb760: 0x001d8003      0x001d9003      0x001da003      0x001db003
0xb770: 0x001dc003      0x001dd003      0x001de003      0x001df003
0xb780: 0x001e0003      0x001e1003      0x001e2003      0x001e3003
0xb790: 0x001e4003      0x001e5003      0x001e6003      0x001e7003
0xb7a0: 0x001e8003      0x001e9003      0x001ea003      0x001eb003
0xb7b0: 0x001ec003      0x001ed003      0x001ee003      0x001ef003
0xb7c0: 0x001f0003      0x001f1003      0x001f2003      0x001f3003
0xb7d0: 0x001f4003      0x001f5003      0x001f6003      0x001f7003
0xb7e0: 0x001f8003      0x001f9003      0x001fa003      0x001fb003
0xb7f0: 0x001fc003      0x001fd003      0x001fe003      0x001ff003
0xb800: 0x00200003      0x00201003      0x00202003      0x00203003
0xb810: 0x00204003      0x00205003      0x00206003      0x00207003
0xb820: 0x00208003      0x00209003      0x0020a003      0x0020b003
0xb830: 0x0020c003      0x0020d003      0x0020e003      0x0020f003
0xb840: 0x00210003      0x00211003      0x00212003      0x00213003
0xb850: 0x00214003      0x00215003      0x00216003      0x00217003
0xb860: 0x00218003      0x00219003      0x0021a003      0x0021b003
0xb870: 0x0021c003      0x0021d003      0x0021e003      0x0021f003
0xb880: 0x00220003      0x00221003      0x00222003      0x00223003
0xb890: 0x00224003      0x00225003      0x00226003      0x00227003
0xb8a0: 0x00228003      0x00229003      0x0022a003      0x0022b003
0xb8b0: 0x0022c003      0x0022d003      0x0022e003      0x0022f003
0xb8c0: 0x00230003      0x00231003      0x00232003      0x00233003
0xb8d0: 0x00234003      0x00235003      0x00236003      0x00237003
0xb8e0: 0x00238003      0x00239003      0x0023a003      0x0023b003
0xb8f0: 0x0023c003      0x0023d003      0x0023e003      0x0023f003
0xb900: 0x00240003      0x00241003      0x00242003      0x00243003
0xb910: 0x00244003      0x00245003      0x00246003      0x00247003
0xb920: 0x00248003      0x00249003      0x0024a003      0x0024b003
0xb930: 0x0024c003      0x0024d003      0x0024e003      0x0024f003
0xb940: 0x00250003      0x00251003      0x00252003      0x00253003
0xb950: 0x00254003      0x00255003      0x00256003      0x00257003
0xb960: 0x00258003      0x00259003      0x0025a003      0x0025b003
0xb970: 0x0025c003      0x0025d003      0x0025e003      0x0025f003
0xb980: 0x00260003      0x00261003      0x00262003      0x00263003
0xb990: 0x00264003      0x00265003      0x00266003      0x00267003
0xb9a0: 0x00268003      0x00269003      0x0026a003      0x0026b003
0xb9b0: 0x0026c003      0x0026d003      0x0026e003      0x0026f003
0xb9c0: 0x00270003      0x00271003      0x00272003      0x00273003
0xb9d0: 0x00274003      0x00275003      0x00276003      0x00277003
0xb9e0: 0x00278003      0x00279003      0x0027a003      0x0027b003
0xb9f0: 0x0027c003      0x0027d003      0x0027e003      0x0027f003
0xba00: 0x00280003      0x00281003      0x00282003      0x00283003
0xba10: 0x00284003      0x00285003      0x00286003      0x00287003
0xba20: 0x00288003      0x00289003      0x0028a003      0x0028b003
0xba30: 0x0028c003      0x0028d003      0x0028e003      0x0028f003
0xba40: 0x00290003      0x00291003      0x00292003      0x00293003
0xba50: 0x00294003      0x00295003      0x00296003      0x00297003
0xba60: 0x00298003      0x00299003      0x0029a003      0x0029b003
0xba70: 0x0029c003      0x0029d003      0x0029e003      0x0029f003
0xba80: 0x002a0003      0x002a1003      0x002a2003      0x002a3003
0xba90: 0x002a4003      0x002a5003      0x002a6003      0x002a7003
0xbaa0: 0x002a8003      0x002a9003      0x002aa003      0x002ab003
0xbab0: 0x002ac003      0x002ad003      0x002ae003      0x002af003
0xbac0: 0x002b0003      0x002b1003      0x002b2003      0x002b3003
0xbad0: 0x002b4003      0x002b5003      0x002b6003      0x002b7003
0xbae0: 0x002b8003      0x002b9003      0x002ba003      0x002bb003
0xbaf0: 0x002bc003      0x002bd003      0x002be003      0x002bf003
0xbb00: 0x002c0003      0x002c1003      0x002c2003      0x002c3003
0xbb10: 0x002c4003      0x002c5003      0x002c6003      0x002c7003
0xbb20: 0x002c8003      0x002c9003      0x002ca003      0x002cb003
0xbb30: 0x002cc003      0x002cd003      0x002ce003      0x002cf003
0xbb40: 0x002d0003      0x002d1003      0x002d2003      0x002d3003
0xbb50: 0x002d4003      0x002d5003      0x002d6003      0x002d7003
0xbb60: 0x002d8003      0x002d9003      0x002da003      0x002db003
0xbb70: 0x002dc003      0x002dd003      0x002de003      0x002df003
0xbb80: 0x002e0003      0x002e1003      0x002e2003      0x002e3003
0xbb90: 0x002e4003      0x002e5003      0x002e6003      0x002e7003
0xbba0: 0x002e8003      0x002e9003      0x002ea003      0x002eb003
0xbbb0: 0x002ec003      0x002ed003      0x002ee003      0x002ef003
0xbbc0: 0x002f0003      0x002f1003      0x002f2003      0x002f3003
0xbbd0: 0x002f4003      0x002f5003      0x002f6003      0x002f7003
0xbbe0: 0x002f8003      0x002f9003      0x002fa003      0x002fb003
0xbbf0: 0x002fc003      0x002fd003      0x002fe003      0x002ff003
0xbc00: 0x00300003      0x00301003      0x00302003      0x00303003
0xbc10: 0x00304003      0x00305003      0x00306003      0x00307003
0xbc20: 0x00308003      0x00309003      0x0030a003      0x0030b003
0xbc30: 0x0030c003      0x0030d003      0x0030e003      0x0030f003
0xbc40: 0x00310003      0x00311003      0x00312003      0x00313003
0xbc50: 0x00314003      0x00315003      0x00316003      0x00317003
0xbc60: 0x00318003      0x00319003      0x0031a003      0x0031b003
0xbc70: 0x0031c003      0x0031d003      0x0031e003      0x0031f003
0xbc80: 0x00320003      0x00321003      0x00322003      0x00323003
0xbc90: 0x00324003      0x00325003      0x00326003      0x00327003
0xbca0: 0x00328003      0x00329003      0x0032a003      0x0032b003
0xbcb0: 0x0032c003      0x0032d003      0x0032e003      0x0032f003
0xbcc0: 0x00330003      0x00331003      0x00332003      0x00333003
0xbcd0: 0x00334003      0x00335003      0x00336003      0x00337003
0xbce0: 0x00338003      0x00339003      0x0033a003      0x0033b003
0xbcf0: 0x0033c003      0x0033d003      0x0033e003      0x0033f003
0xbd00: 0x00340003      0x00341003      0x00342003      0x00343003
0xbd10: 0x00344003      0x00345003      0x00346003      0x00347003
0xbd20: 0x00348003      0x00349003      0x0034a003      0x0034b003
0xbd30: 0x0034c003      0x0034d003      0x0034e003      0x0034f003
0xbd40: 0x00350003      0x00351003      0x00352003      0x00353003
0xbd50: 0x00354003      0x00355003      0x00356003      0x00357003
0xbd60: 0x00358003      0x00359003      0x0035a003      0x0035b003
0xbd70: 0x0035c003      0x0035d003      0x0035e003      0x0035f003
0xbd80: 0x00360003      0x00361003      0x00362003      0x00363003
0xbd90: 0x00364003      0x00365003      0x00366003      0x00367003
0xbda0: 0x00368003      0x00369003      0x0036a003      0x0036b003
0xbdb0: 0x0036c003      0x0036d003      0x0036e003      0x0036f003
0xbdc0: 0x00370003      0x00371003      0x00372003      0x00373003
0xbdd0: 0x00374003      0x00375003      0x00376003      0x00377003
0xbde0: 0x00378003      0x00379003      0x0037a003      0x0037b003
0xbdf0: 0x0037c003      0x0037d003      0x0037e003      0x0037f003
0xbe00: 0x00380003      0x00381003      0x00382003      0x00383003
0xbe10: 0x00384003      0x00385003      0x00386003      0x00387003
0xbe20: 0x00388003      0x00389003      0x0038a003      0x0038b003
0xbe30: 0x0038c003      0x0038d003      0x0038e003      0x0038f003
0xbe40: 0x00390003      0x00391003      0x00392003      0x00393003
0xbe50: 0x00394003      0x00395003      0x00396003      0x00397003
0xbe60: 0x00398003      0x00399003      0x0039a003      0x0039b003
0xbe70: 0x0039c003      0x0039d003      0x0039e003      0x0039f003
0xbe80: 0x003a0003      0x003a1003      0x003a2003      0x003a3003
0xbe90: 0x003a4003      0x003a5003      0x003a6003      0x003a7003
0xbea0: 0x003a8003      0x003a9003      0x003aa003      0x003ab003
0xbeb0: 0x003ac003      0x003ad003      0x003ae003      0x003af003
0xbec0: 0x003b0003      0x003b1003      0x003b2003      0x003b3003
0xbed0: 0x003b4003      0x003b5003      0x003b6003      0x003b7003
0xbee0: 0x003b8003      0x003b9003      0x003ba003      0x003bb003
0xbef0: 0x003bc003      0x003bd003      0x003be003      0x003bf003
0xbf00: 0x003c0003      0x003c1003      0x003c2003      0x003c3003
0xbf10: 0x003c4003      0x003c5003      0x003c6003      0x003c7003
0xbf20: 0x003c8003      0x003c9003      0x003ca003      0x003cb003
0xbf30: 0x003cc003      0x003cd003      0x003ce003      0x003cf003
0xbf40: 0x003d0003      0x003d1003      0x003d2003      0x003d3003
0xbf50: 0x003d4003      0x003d5003      0x003d6003      0x003d7003
0xbf60: 0x003d8003      0x003d9003      0x003da003      0x003db003
0xbf70: 0x003dc003      0x003dd003      0x003de003      0x003df003
0xbf80: 0x003e0003      0x003e1003      0x003e2003      0x003e3003
0xbf90: 0x003e4003      0x003e5003      0x003e6003      0x003e7003
0xbfa0: 0x003e8003      0x003e9003      0x003ea003      0x003eb003
0xbfb0: 0x003ec003      0x003ed003      0x003ee003      0x003ef003
0xbfc0: 0x003f0003      0x003f1003      0x003f2003      0x003f3003
0xbfd0: 0x003f4003      0x003f5003      0x003f6003      0x003f7003
0xbfe0: 0x003f8003      0x003f9003      0x003fa003      0x003fb003
0xbff0: 0x003fc003      0x003fd003      0x003fe003      0x003ff003

And this is the page table at 0xC000: 

x/1024w 0xC000

0xc000: 0x00010003      0x00011003      0x00012003      0x00013003
0xc010: 0x00014003      0x00015003      0x00016003      0x00017003
0xc020: 0x00018003      0x00019003      0x0001a003      0x0001b003
0xc030: 0x0001c003      0x0001d003      0x0001e003      0x0001f003
0xc040: 0x00020003      0x00021003      0x00022003      0x00023003
0xc050: 0x00024003      0x00025003      0x00026003      0x00027003
0xc060: 0x00028003      0x00029003      0x0002a003      0x0002b003
0xc070: 0x0002c003      0x0002d003      0x0002e003      0x0002f003
0xc080: 0x00030003      0x00031003      0x00032003      0x00033003
0xc090: 0x00034003      0x00035003      0x00036003      0x00037003
0xc0a0: 0x00038003      0x00039003      0x0003a003      0x0003b003
0xc0b0: 0x0003c003      0x0003d003      0x0003e003      0x0003f003
0xc0c0: 0x00040003      0x00041003      0x00042003      0x00043003
0xc0d0: 0x00044003      0x00045003      0x00046003      0x00047003
0xc0e0: 0x00048003      0x00049003      0x0004a003      0x0004b003
0xc0f0: 0x0004c003      0x0004d003      0x0004e003      0x0004f003
0xc100: 0x00050003      0x00051003      0x00052003      0x00053003
0xc110: 0x00054003      0x00055003      0x00056003      0x00057003
0xc120: 0x00058003      0x00059003      0x0005a003      0x0005b003
0xc130: 0x0005c003      0x0005d003      0x0005e003      0x0005f003
0xc140: 0x00060003      0x00061003      0x00062003      0x00063003
0xc150: 0x00064003      0x00065003      0x00066003      0x00067003
0xc160: 0x00068003      0x00069003      0x0006a003      0x0006b003
0xc170: 0x0006c003      0x0006d003      0x0006e003      0x0006f003
0xc180: 0x00070003      0x00071003      0x00072003      0x00073003
0xc190: 0x00074003      0x00075003      0x00076003      0x00077003
0xc1a0: 0x00078003      0x00079003      0x0007a003      0x0007b003
0xc1b0: 0x0007c003      0x0007d003      0x0007e003      0x0007f003
0xc1c0: 0x00080003      0x00081003      0x00082003      0x00083003
0xc1d0: 0x00084003      0x00085003      0x00086003      0x00087003
0xc1e0: 0x00088003      0x00089003      0x0008a003      0x0008b003
0xc1f0: 0x0008c003      0x0008d003      0x0008e003      0x0008f003
0xc200: 0x00090003      0x00091003      0x00092003      0x00093003
0xc210: 0x00094003      0x00095003      0x00096003      0x00097003
0xc220: 0x00098003      0x00099003      0x0009a003      0x0009b003
0xc230: 0x0009c003      0x0009d003      0x0009e003      0x0009f003
0xc240: 0x000a0003      0x000a1003      0x000a2003      0x000a3003
0xc250: 0x000a4003      0x000a5003      0x000a6003      0x000a7003
0xc260: 0x000a8003      0x000a9003      0x000aa003      0x000ab003
0xc270: 0x000ac003      0x000ad003      0x000ae003      0x000af003
0xc280: 0x000b0003      0x000b1003      0x000b2003      0x000b3003
0xc290: 0x000b4003      0x000b5003      0x000b6003      0x000b7003
0xc2a0: 0x000b8003      0x000b9003      0x000ba003      0x000bb003
0xc2b0: 0x000bc003      0x000bd003      0x000be003      0x000bf003
0xc2c0: 0x000c0003      0x000c1003      0x000c2003      0x000c3003
0xc2d0: 0x000c4003      0x000c5003      0x000c6003      0x000c7003
0xc2e0: 0x000c8003      0x000c9003      0x000ca003      0x000cb003
0xc2f0: 0x000cc003      0x000cd003      0x000ce003      0x000cf003
0xc300: 0x000d0003      0x000d1003      0x000d2003      0x000d3003
0xc310: 0x000d4003      0x000d5003      0x000d6003      0x000d7003
0xc320: 0x000d8003      0x000d9003      0x000da003      0x000db003
0xc330: 0x000dc003      0x000dd003      0x000de003      0x000df003
0xc340: 0x000e0003      0x000e1003      0x000e2003      0x000e3003
0xc350: 0x000e4003      0x000e5003      0x000e6003      0x000e7003
0xc360: 0x000e8003      0x000e9003      0x000ea003      0x000eb003
0xc370: 0x000ec003      0x000ed003      0x000ee003      0x000ef003
0xc380: 0x000f0003      0x000f1003      0x000f2003      0x000f3003
0xc390: 0x000f4003      0x000f5003      0x000f6003      0x000f7003
0xc3a0: 0x000f8003      0x000f9003      0x000fa003      0x000fb003
0xc3b0: 0x000fc003      0x000fd003      0x000fe003      0x000ff003
0xc3c0: 0x00100003      0x00101003      0x00102003      0x00103003
0xc3d0: 0x00104003      0x00105003      0x00106003      0x00107003
0xc3e0: 0x00108003      0x00109003      0x0010a003      0x0010b003
0xc3f0: 0x0010c003      0x0010d003      0x0010e003      0x0010f003
0xc400: 0x00110003      0x00111003      0x00112003      0x00113003
0xc410: 0x00114003      0x00115003      0x00116003      0x00117003
0xc420: 0x00118003      0x00119003      0x0011a003      0x0011b003
0xc430: 0x0011c003      0x0011d003      0x0011e003      0x0011f003
0xc440: 0x00120003      0x00121003      0x00122003      0x00123003
0xc450: 0x00124003      0x00125003      0x00126003      0x00127003
0xc460: 0x00128003      0x00129003      0x0012a003      0x0012b003
0xc470: 0x0012c003      0x0012d003      0x0012e003      0x0012f003
0xc480: 0x00130003      0x00131003      0x00132003      0x00133003
0xc490: 0x00134003      0x00135003      0x00136003      0x00137003
0xc4a0: 0x00138003      0x00139003      0x0013a003      0x0013b003
0xc4b0: 0x0013c003      0x0013d003      0x0013e003      0x0013f003
0xc4c0: 0x00140003      0x00141003      0x00142003      0x00143003
0xc4d0: 0x00144003      0x00145003      0x00146003      0x00147003
0xc4e0: 0x00148003      0x00149003      0x0014a003      0x0014b003
0xc4f0: 0x0014c003      0x0014d003      0x0014e003      0x0014f003
0xc500: 0x00150003      0x00151003      0x00152003      0x00153003
0xc510: 0x00154003      0x00155003      0x00156003      0x00157003
0xc520: 0x00158003      0x00159003      0x0015a003      0x0015b003
0xc530: 0x0015c003      0x0015d003      0x0015e003      0x0015f003
0xc540: 0x00160003      0x00161003      0x00162003      0x00163003
0xc550: 0x00164003      0x00165003      0x00166003      0x00167003
0xc560: 0x00168003      0x00169003      0x0016a003      0x0016b003
0xc570: 0x0016c003      0x0016d003      0x0016e003      0x0016f003
0xc580: 0x00170003      0x00171003      0x00172003      0x00173003
0xc590: 0x00174003      0x00175003      0x00176003      0x00177003
0xc5a0: 0x00178003      0x00179003      0x0017a003      0x0017b003
0xc5b0: 0x0017c003      0x0017d003      0x0017e003      0x0017f003
0xc5c0: 0x00180003      0x00181003      0x00182003      0x00183003
0xc5d0: 0x00184003      0x00185003      0x00186003      0x00187003
0xc5e0: 0x00188003      0x00189003      0x0018a003      0x0018b003
0xc5f0: 0x0018c003      0x0018d003      0x0018e003      0x0018f003
0xc600: 0x00190003      0x00191003      0x00192003      0x00193003
0xc610: 0x00194003      0x00195003      0x00196003      0x00197003
0xc620: 0x00198003      0x00199003      0x0019a003      0x0019b003
0xc630: 0x0019c003      0x0019d003      0x0019e003      0x0019f003
0xc640: 0x001a0003      0x001a1003      0x001a2003      0x001a3003
0xc650: 0x001a4003      0x001a5003      0x001a6003      0x001a7003
0xc660: 0x001a8003      0x001a9003      0x001aa003      0x001ab003
0xc670: 0x001ac003      0x001ad003      0x001ae003      0x001af003
0xc680: 0x001b0003      0x001b1003      0x001b2003      0x001b3003
0xc690: 0x001b4003      0x001b5003      0x001b6003      0x001b7003
0xc6a0: 0x001b8003      0x001b9003      0x001ba003      0x001bb003
0xc6b0: 0x001bc003      0x001bd003      0x001be003      0x001bf003
0xc6c0: 0x001c0003      0x001c1003      0x001c2003      0x001c3003
0xc6d0: 0x001c4003      0x001c5003      0x001c6003      0x001c7003
0xc6e0: 0x001c8003      0x001c9003      0x001ca003      0x001cb003
0xc6f0: 0x001cc003      0x001cd003      0x001ce003      0x001cf003
0xc700: 0x001d0003      0x001d1003      0x001d2003      0x001d3003
0xc710: 0x001d4003      0x001d5003      0x001d6003      0x001d7003
0xc720: 0x001d8003      0x001d9003      0x001da003      0x001db003
0xc730: 0x001dc003      0x001dd003      0x001de003      0x001df003
0xc740: 0x001e0003      0x001e1003      0x001e2003      0x001e3003
0xc750: 0x001e4003      0x001e5003      0x001e6003      0x001e7003
0xc760: 0x001e8003      0x001e9003      0x001ea003      0x001eb003
0xc770: 0x001ec003      0x001ed003      0x001ee003      0x001ef003
0xc780: 0x001f0003      0x001f1003      0x001f2003      0x001f3003
0xc790: 0x001f4003      0x001f5003      0x001f6003      0x001f7003
0xc7a0: 0x001f8003      0x001f9003      0x001fa003      0x001fb003
0xc7b0: 0x001fc003      0x001fd003      0x001fe003      0x001ff003
0xc7c0: 0x00200003      0x00201003      0x00202003      0x00203003
0xc7d0: 0x00204003      0x00205003      0x00206003      0x00207003
0xc7e0: 0x00208003      0x00209003      0x0020a003      0x0020b003
0xc7f0: 0x0020c003      0x0020d003      0x0020e003      0x0020f003
0xc800: 0x00210003      0x00211003      0x00212003      0x00213003
0xc810: 0x00214003      0x00215003      0x00216003      0x00217003
0xc820: 0x00218003      0x00219003      0x0021a003      0x0021b003
0xc830: 0x0021c003      0x0021d003      0x0021e003      0x0021f003
0xc840: 0x00220003      0x00221003      0x00222003      0x00223003
0xc850: 0x00224003      0x00225003      0x00226003      0x00227003
0xc860: 0x00228003      0x00229003      0x0022a003      0x0022b003
0xc870: 0x0022c003      0x0022d003      0x0022e003      0x0022f003
0xc880: 0x00230003      0x00231003      0x00232003      0x00233003
0xc890: 0x00234003      0x00235003      0x00236003      0x00237003
0xc8a0: 0x00238003      0x00239003      0x0023a003      0x0023b003
0xc8b0: 0x0023c003      0x0023d003      0x0023e003      0x0023f003
0xc8c0: 0x00240003      0x00241003      0x00242003      0x00243003
0xc8d0: 0x00244003      0x00245003      0x00246003      0x00247003
0xc8e0: 0x00248003      0x00249003      0x0024a003      0x0024b003
0xc8f0: 0x0024c003      0x0024d003      0x0024e003      0x0024f003
0xc900: 0x00250003      0x00251003      0x00252003      0x00253003
0xc910: 0x00254003      0x00255003      0x00256003      0x00257003
0xc920: 0x00258003      0x00259003      0x0025a003      0x0025b003
0xc930: 0x0025c003      0x0025d003      0x0025e003      0x0025f003
0xc940: 0x00260003      0x00261003      0x00262003      0x00263003
0xc950: 0x00264003      0x00265003      0x00266003      0x00267003
0xc960: 0x00268003      0x00269003      0x0026a003      0x0026b003
0xc970: 0x0026c003      0x0026d003      0x0026e003      0x0026f003
0xc980: 0x00270003      0x00271003      0x00272003      0x00273003
0xc990: 0x00274003      0x00275003      0x00276003      0x00277003
0xc9a0: 0x00278003      0x00279003      0x0027a003      0x0027b003
0xc9b0: 0x0027c003      0x0027d003      0x0027e003      0x0027f003
0xc9c0: 0x00280003      0x00281003      0x00282003      0x00283003
0xc9d0: 0x00284003      0x00285003      0x00286003      0x00287003
0xc9e0: 0x00288003      0x00289003      0x0028a003      0x0028b003
0xc9f0: 0x0028c003      0x0028d003      0x0028e003      0x0028f003
0xca00: 0x00290003      0x00291003      0x00292003      0x00293003
0xca10: 0x00294003      0x00295003      0x00296003      0x00297003
0xca20: 0x00298003      0x00299003      0x0029a003      0x0029b003
0xca30: 0x0029c003      0x0029d003      0x0029e003      0x0029f003
0xca40: 0x002a0003      0x002a1003      0x002a2003      0x002a3003
0xca50: 0x002a4003      0x002a5003      0x002a6003      0x002a7003
0xca60: 0x002a8003      0x002a9003      0x002aa003      0x002ab003
0xca70: 0x002ac003      0x002ad003      0x002ae003      0x002af003
0xca80: 0x002b0003      0x002b1003      0x002b2003      0x002b3003
0xca90: 0x002b4003      0x002b5003      0x002b6003      0x002b7003
0xcaa0: 0x002b8003      0x002b9003      0x002ba003      0x002bb003
0xcab0: 0x002bc003      0x002bd003      0x002be003      0x002bf003
0xcac0: 0x002c0003      0x002c1003      0x002c2003      0x002c3003
0xcad0: 0x002c4003      0x002c5003      0x002c6003      0x002c7003
0xcae0: 0x002c8003      0x002c9003      0x002ca003      0x002cb003
0xcaf0: 0x002cc003      0x002cd003      0x002ce003      0x002cf003
0xcb00: 0x002d0003      0x002d1003      0x002d2003      0x002d3003
0xcb10: 0x002d4003      0x002d5003      0x002d6003      0x002d7003
0xcb20: 0x002d8003      0x002d9003      0x002da003      0x002db003
0xcb30: 0x002dc003      0x002dd003      0x002de003      0x002df003
0xcb40: 0x002e0003      0x002e1003      0x002e2003      0x002e3003
0xcb50: 0x002e4003      0x002e5003      0x002e6003      0x002e7003
0xcb60: 0x002e8003      0x002e9003      0x002ea003      0x002eb003
0xcb70: 0x002ec003      0x002ed003      0x002ee003      0x002ef003
0xcb80: 0x002f0003      0x002f1003      0x002f2003      0x002f3003
0xcb90: 0x002f4003      0x002f5003      0x002f6003      0x002f7003
0xcba0: 0x002f8003      0x002f9003      0x002fa003      0x002fb003
0xcbb0: 0x002fc003      0x002fd003      0x002fe003      0x002ff003
0xcbc0: 0x00300003      0x00301003      0x00302003      0x00303003
0xcbd0: 0x00304003      0x00305003      0x00306003      0x00307003
0xcbe0: 0x00308003      0x00309003      0x0030a003      0x0030b003
0xcbf0: 0x0030c003      0x0030d003      0x0030e003      0x0030f003
0xcc00: 0x00310003      0x00311003      0x00312003      0x00313003
0xcc10: 0x00314003      0x00315003      0x00316003      0x00317003
0xcc20: 0x00318003      0x00319003      0x0031a003      0x0031b003
0xcc30: 0x0031c003      0x0031d003      0x0031e003      0x0031f003
0xcc40: 0x00320003      0x00321003      0x00322003      0x00323003
0xcc50: 0x00324003      0x00325003      0x00326003      0x00327003
0xcc60: 0x00328003      0x00329003      0x0032a003      0x0032b003
0xcc70: 0x0032c003      0x0032d003      0x0032e003      0x0032f003
0xcc80: 0x00330003      0x00331003      0x00332003      0x00333003
0xcc90: 0x00334003      0x00335003      0x00336003      0x00337003
0xcca0: 0x00338003      0x00339003      0x0033a003      0x0033b003
0xccb0: 0x0033c003      0x0033d003      0x0033e003      0x0033f003
0xccc0: 0x00340003      0x00341003      0x00342003      0x00343003
0xccd0: 0x00344003      0x00345003      0x00346003      0x00347003
0xcce0: 0x00348003      0x00349003      0x0034a003      0x0034b003
0xccf0: 0x0034c003      0x0034d003      0x0034e003      0x0034f003
0xcd00: 0x00350003      0x00351003      0x00352003      0x00353003
0xcd10: 0x00354003      0x00355003      0x00356003      0x00357003
0xcd20: 0x00358003      0x00359003      0x0035a003      0x0035b003
0xcd30: 0x0035c003      0x0035d003      0x0035e003      0x0035f003
0xcd40: 0x00360003      0x00361003      0x00362003      0x00363003
0xcd50: 0x00364003      0x00365003      0x00366003      0x00367003
0xcd60: 0x00368003      0x00369003      0x0036a003      0x0036b003
0xcd70: 0x0036c003      0x0036d003      0x0036e003      0x0036f003
0xcd80: 0x00370003      0x00371003      0x00372003      0x00373003
0xcd90: 0x00374003      0x00375003      0x00376003      0x00377003
0xcda0: 0x00378003      0x00379003      0x0037a003      0x0037b003
0xcdb0: 0x0037c003      0x0037d003      0x0037e003      0x0037f003
0xcdc0: 0x00380003      0x00381003      0x00382003      0x00383003
0xcdd0: 0x00384003      0x00385003      0x00386003      0x00387003
0xcde0: 0x00388003      0x00389003      0x0038a003      0x0038b003
0xcdf0: 0x0038c003      0x0038d003      0x0038e003      0x0038f003
0xce00: 0x00390003      0x00391003      0x00392003      0x00393003
0xce10: 0x00394003      0x00395003      0x00396003      0x00397003
0xce20: 0x00398003      0x00399003      0x0039a003      0x0039b003
0xce30: 0x0039c003      0x0039d003      0x0039e003      0x0039f003
0xce40: 0x003a0003      0x003a1003      0x003a2003      0x003a3003
0xce50: 0x003a4003      0x003a5003      0x003a6003      0x003a7003
0xce60: 0x003a8003      0x003a9003      0x003aa003      0x003ab003
0xce70: 0x003ac003      0x003ad003      0x003ae003      0x003af003
0xce80: 0x003b0003      0x003b1003      0x003b2003      0x003b3003
0xce90: 0x003b4003      0x003b5003      0x003b6003      0x003b7003
0xcea0: 0x003b8003      0x003b9003      0x003ba003      0x003bb003
0xceb0: 0x003bc003      0x003bd003      0x003be003      0x003bf003
0xcec0: 0x003c0003      0x003c1003      0x003c2003      0x003c3003
0xced0: 0x003c4003      0x003c5003      0x003c6003      0x003c7003
0xcee0: 0x003c8003      0x003c9003      0x003ca003      0x003cb003
0xcef0: 0x003cc003      0x003cd003      0x003ce003      0x003cf003
0xcf00: 0x003d0003      0x003d1003      0x003d2003      0x003d3003
0xcf10: 0x003d4003      0x003d5003      0x003d6003      0x003d7003
0xcf20: 0x003d8003      0x003d9003      0x003da003      0x003db003
0xcf30: 0x003dc003      0x003dd003      0x003de003      0x003df003
0xcf40: 0x003e0003      0x003e1003      0x003e2003      0x003e3003
0xcf50: 0x003e4003      0x003e5003      0x003e6003      0x003e7003
0xcf60: 0x003e8003      0x003e9003      0x003ea003      0x003eb003
0xcf70: 0x003ec003      0x003ed003      0x003ee003      0x003ef003
0xcf80: 0x003f0003      0x003f1003      0x003f2003      0x003f3003
0xcf90: 0x003f4003      0x003f5003      0x003f6003      0x003f7003
0xcfa0: 0x003f8003      0x003f9003      0x003fa003      0x003fb003
0xcfb0: 0x003fc003      0x003fd003      0x003fe003      0x003ff003
0xcfc0: 0x00400003      0x00401003      0x00402003      0x00403003
0xcfd0: 0x00404003      0x00405003      0x00406003      0x00407003
0xcfe0: 0x00408003      0x00409003      0x0040a003      0x0040b003
0xcff0: 0x0040c003      0x0040d003      0x0040e003      0x0040f003

Nothing unusual about that

Except that the page corresponding to 0xC0100000 is the 0x100th entry in this
page table, which is NOT 0x100000 (as we'd want) but rather is 0x50000, which
is STUPID ME IDIOT ARGH!  

Though even now, triple fault on my machine, and Bochs still says page not
present, though GDB+QEMU tells me that the page table at 0xC000 starts as: 

x/1024w 0xC000

0xc000: 0x00000000      0x00000000      0x00000000      0x00000000
0xc010: 0x00000000      0x00000000      0x00000000      0x00000000
0xc020: 0x00000000      0x00000000      0x00000000      0x00000000
0xc030: 0x00000000      0x00000000      0x00000000      0x00000000
0xc040: 0x00000000      0x00000000      0x00000000      0x00000000
0xc050: 0x00000000      0x00000000      0x00000000      0x00000000
0xc060: 0x00000000      0x00000000      0x00000000      0x00000000
0xc070: 0x00000000      0x00000000      0x00000000      0x00000000
0xc080: 0x00000000      0x00000000      0x00000000      0x00000000
0xc090: 0x00000000      0x00000000      0x00000000      0x00000000
0xc0a0: 0x00000000      0x00000000      0x00000000      0x00000000
0xc0b0: 0x00000000      0x00000000      0x00000000      0x00000000
0xc0c0: 0x00000000      0x00000000      0x00000000      0x00000000
0xc0d0: 0x00000000      0x00000000      0x00000000      0x00000000
0xc0e0: 0x00000000      0x00000000      0x00000000      0x00000000
0xc0f0: 0x00000000      0x00000000      0x00000000      0x00000000
0xc100: 0x00010003      0x00011003      0x00012003      0x00013003
0xc110: 0x00014003      0x00015003      0x00016003      0x00017003
0xc120: 0x00018003      0x00019003      0x0001a003      0x0001b003
0xc130: 0x0001c003      0x0001d003      0x0001e003      0x0001f003
0xc140: 0x00020003      0x00021003      0x00022003      0x00023003
0xc150: 0x00024003      0x00025003      0x00026003      0x00027003
0xc160: 0x00028003      0x00029003      0x0002a003      0x0002b003
0xc170: 0x0002c003      0x0002d003      0x0002e003      0x0002f003
0xc180: 0x00030003      0x00031003      0x00032003      0x00033003
0xc190: 0x00034003      0x00035003      0x00036003      0x00037003
0xc1a0: 0x00038003      0x00039003      0x0003a003      0x0003b003
0xc1b0: 0x0003c003      0x0003d003      0x0003e003      0x0003f003
0xc1c0: 0x00040003      0x00041003      0x00042003      0x00043003
0xc1d0: 0x00044003      0x00045003      0x00046003      0x00047003
0xc1e0: 0x00048003      0x00049003      0x0004a003      0x0004b003
0xc1f0: 0x0004c003      0x0004d003      0x0004e003      0x0004f003
0xc200: 0x00050003      0x00051003      0x00052003      0x00053003
0xc210: 0x00054003      0x00055003      0x00056003      0x00057003
0xc220: 0x00058003      0x00059003      0x0005a003      0x0005b003
0xc230: 0x0005c003      0x0005d003      0x0005e003      0x0005f003
0xc240: 0x00060003      0x00061003      0x00062003      0x00063003
0xc250: 0x00064003      0x00065003      0x00066003      0x00067003
0xc260: 0x00068003      0x00069003      0x0006a003      0x0006b003
0xc270: 0x0006c003      0x0006d003      0x0006e003      0x0006f003
0xc280: 0x00070003      0x00071003      0x00072003      0x00073003
0xc290: 0x00074003      0x00075003      0x00076003      0x00077003
0xc2a0: 0x00078003      0x00079003      0x0007a003      0x0007b003
0xc2b0: 0x0007c003      0x0007d003      0x0007e003      0x0007f003
0xc2c0: 0x00080003      0x00081003      0x00082003      0x00083003
0xc2d0: 0x00084003      0x00085003      0x00086003      0x00087003
0xc2e0: 0x00088003      0x00089003      0x0008a003      0x0008b003
0xc2f0: 0x0008c003      0x0008d003      0x0008e003      0x0008f003
0xc300: 0x00090003      0x00091003      0x00092003      0x00093003
0xc310: 0x00094003      0x00095003      0x00096003      0x00097003
0xc320: 0x00098003      0x00099003      0x0009a003      0x0009b003
0xc330: 0x0009c003      0x0009d003      0x0009e003      0x0009f003
0xc340: 0x000a0003      0x000a1003      0x000a2003      0x000a3003
0xc350: 0x000a4003      0x000a5003      0x000a6003      0x000a7003
...

which looks better.  Pagedir is as before.  

Still triple fauts everywhere.  Hmph.  

230817


20090401:001731:Counting

I can't count zeros.  

Host: How many zeros are in the number 0x10000?  
Me: 5

Yeah...

001900

20090401:015050:General thoughts

A more big-picture thing now: What we want at the end is for programs to have
their interfaces entirely defined programmatically.  That is, for example,
where programs would ordinarily have a GUI element--a slider, say--that sets
some variable, it'll now have a means of doing so entirely via IPC, which can
be given a layer in the form of a GUI or a shell interface or whatever.  The
shell interface element of this would be reasonably useful, so as long as this
is implemented intelligently it is necessarily strictly better.  

015439


20090401:210121:Hmph

Still no word on what's wrong.  Let's work through what happens: 

jmps to 0xC0100000, so needs to find that instruction in PTs.  

0xC0100000 >> 22 = 0x300, so will look in table 0x300, which, as we see in the
above mappings, is given as the table at 0xC000.  Further, 0xC0100000 %
0x1000000 = 0x100000, and 0x100000 / 0x1000 = 0x100, so the 0x100th entry in
our page table should be the one we're accessing, and behold, that points to
memory address 0x10000, which is where the kernel is.  

Memdump from gdb is suspicious--there is stuff starting around 0xffd0.  Are we
overwriting code by dumping the kernel at 0x10000?  

211128

20090402:041041:I'm an IDIOT

The above analysis is correct, but to put stuff in the 0x300th entry of the
pagedir, you DON'T use 

mov [PD_START+0x300],stuff

but rather you use 

mov [PD_START+4*0x300],stuff

Problem solved.  

041246

20090402:173522:Where are we now?

Now this week is over, we have a clear plan for what needs to be done next,
now that all the low-level fiddliness is out of the way.  

Current problems: 

	Cannot move the stack.  

	        When I try any further calls triple fault.  Unimportant, as
	        it is out of the way anyway.

	Interrupts are broken. 

		Pressing key->triple fault.  Possibly put back in the BASE
		offset.

In the short term: 

   Allow allocation for kernel structures

   	 Have separate arrays of pointers for each type of struct and either
   	 have separate areas in vmem allocated for sticking in the actual
   	 structures (with stored corresponding array of pointers) 

   Prepare the page tables for the kernel mapping

   	 These will just be analogous to the ones prepared in stage2, except
   	 without the identity mapping of the first loads.  

   Get the ramdisk working

       	 Loading it into memory in the correct place should no longer be a
       	 problem, and the code for access/writing is already in place--just
       	 needs a good debug.  

   Get multitasking and IPC working

         This is the single biggest goal, and is the aim for by the end of the
         month.  The scheme and associated structures I intend to use have
         been documented extensively elsewhere, but there is much code yet to
         write.

   After this, need to get devices set up with their memory-mapped areas
   mapped in PTs, and need to get into userspace (which should strictly be
   some boilerplate).

Other things that need fixing (For a release-quality system): 

   Propsely disable A20 (stage1), detect video modes (stage2), and work out
   memory map (stage2), passing this information to the kernel for reporting
   during proper boot in some big struct.  Brendan has rants about all of
   these that will be handy.  

In the long term: 

   Work out a decent interface descriptor language, as well as a decent way of
   hooking both a GUI and a shell interface into this.  Ideally, this will
   allow automation of dealings with programs where before you'd want to say
   `move this slider a random amount', now it's `use the shell-side of the
   interface (or just the bytestream through IPC, if you use the appropriate
   protocol) to set the value to a random thing (which also happens to be the
   value set by the slider of interest).  

   However, this lays the question of where are the interface descriptors
   stored?  We could make an executable format that is amenable to this sort
   of thing, which would be good, but it'd be nice to at least be able to deal
   with ELFs and the like as well.  To this end, we'd need to make a bunch of
   includes available for processing IPC based possibly on an auxilliary
   interface descriptor file (which could be in some analog of a resource fork
   or something, to more canonically associate it with the file, but this is
   not an interesting part of the design).  

03:064032

20090404:135816:Kernel Structures

Because everything's going to be statically allocated, we'll need some thought
input before we start hacking away--in particular, some kind of decent
organization.  

For starters, let's bring that list of structs from above down here: 

	Kernel structures: 
	   PTs and PDs
	   Threads
	   Nodes
	   Connections
	   Kernel Stacks (for reentrancy)

It may be possible to dump the concept of threads and go entirely with nodes,
which I guess we'll do for now.  

So: 


Kernel structures: 
   Page Tables
   Page Directories
   Nodes
   Connections
   Kernel Stacks

Kernel stacks can be assumed to take 0x4000 bytes (0x1000 at the start for a
canary page (for detecting overflow) and the other 0x3000 for actual space)

The rest can be taken to be 0x1000 bytes: PTs and PDs are naturally 4K, and
the node structure can have a corresponding list of connectionIDs following
the (small) structure.  It may be possible to allow arbitrarily many
connections by making a linked-list of 0x1000-byte-aligned frames, each with
an array of associated connectionIDs for the node.  

06:182215

20090406:210327:IPC Again

Another thought on augmenting the current plan for IPC: Rather than allowing
the splicing of connections, connections are simply given associated `ports'.
Then anyone who wants to splice a connection would instead make a connection
on that particular port.  It means the splicing thing is gone, but the only
real difference is that instead of connecting and saying `give me a
connection' you'd connect to listen on whatever port.  

Decisions, decisions...

07:012644

20090407:012653:Kernel Struct Logic

The kernel first has its physmem manager with pre-allocated imap, and then
it's space manager (for structures) with pre-allocated imap.  

This seems to give rise to something of a chicken-and-egg problem though--we
need to map the kernel directory somewhere, yet we need the kernel directory
to map anything anywhere.  

The obvious solution is to stick the kernel directory just anywhere (well,
somewhere specific) in kernel-land and then to go from there.  Maybe it's
best, maybe not, but it's what we'll do.  The space 0xC0000000+EOK to
0xC1000000 will serve this purpose (provided EOK will always stay below
0x1000000, but I very much suspect this to be the case).  

Then, we'll need an imap for 0x1000-byte blocks in the area
0xC1000000-0xD8000000 and another for 0x4000-byte blocks in the area
0xD8000000-0xF0000000.  Then, we'll need arrays for the various structures.
These can either be given as linked-lists of the 0x1000-byte blocks or by
fixed-size arrays in the kernel's space (0xC0000000-0xC1000000).  The latter
will probably be the final design, but we'll stick with the former for now.  

Then the kernel API will essentially be make_node, dump_node, make_connection,
dump_connection, so we'd write these next, and this is where things get
hairy.  

074747


20090413:165452:Reboot

After a CATAM break, we're back.  To finish the kernel there remain six things
to do: 

   1. Initize page tables
   2. Write kalloc for kernel structures
   3. Ramdisk
   4. Multitasking
   5. IPC
   6. Setup syscalls

The code for 1, 3, 4, and 6 already exists (just neads tweaking/testing), so
we plan for 2 and 5 now, which have been discussed in varying levels of detail
already, but we consolidate here, and refresh the ideas a little.  

2: 

API: 

alloc_node: creates pagedir (in 0xC1000000-0xD8000000), kernel stack (in
0xD8000000-0xF00000000), and fills node struct with appropriate values.  

dump_node: removes associated pagedir and kernel stack as well as all
associated connections/endpoints.  

alloc_connection: 

...

5: 

connect(): allocates connection and returns its ID (in this implementation, its
	 index in the array) or an error code if there was a permissions problem or
	 other failure.  This is exposed through a system call.  

send: 


How to do some things with connections: 

If I want to set up an `event-driven' sort of system on top of this, it's
quite easy as the system is almost essentially event-driven at its core.  When
you get a message, a `receive' function (registered as part of being a node)
is called, which can parse its arguments and pass them on to the higher level
code as a `mouse event' or `packets done sending' or whatever after some big
switch-statement block.  

This message handler, then, is like a super-event handler, which calls all
higher-level event-handlers, and nothing else.  

For example, to read a file, we can use the following pseudo-C code: 

void main()
{
	a = async_read_file("blah.txt");
	b = async_read_file("bloo.txt");
	do_stuff();
}

void read_complete(void *data, int length, int id)
{
	if(id == a) display_stuff_to_screen(data);
	else new_tab(data);
}

void recv(u32 from_ID, int argc, void **args)
{
	if(from_ID == fs_node && args[0] == a){
		   read_complete(args[1], args[2], a);
	}
}

where the `handler' preempts the running process (but is not itself
preemptable).  

...


20090627:014651:Reboot II

So we return, Class I (and WP!) in hand, to survey the current situation, make
a quick note of some general thoughts relating to future directions, and
review the tasks currently at hand.  I am at camp presently and have brought
bits of computer with which to test.  However, the video card I grabbed on the
way out the door doesn't seem to support VESA mode 0x4115, so I have written a
first attempt at a better mode detection/setting within the bootloader, which
needs further testing/debugging.  This is difficult, however, without knowing
quite what modes this card supports (though evidently it does support VESA2).
To this end, I've written text-mode monitor-handling code that I should be
able to use to get what modes I'm seeing from the card (assuming the assembler
to do that is in any way correct).

So once that's sorted (or, perhaps, in parallel with the sorting of that), we
need to handle the remainder of the kernel.  In particular, we need to start
with the paging code.  

We had last time that we were going to map the kernel at 0xC1000000, with the
kernel stack at 0xC0000000

       
For some general thoughts, one thing that might be nice to have is to simplify
deployment.  If we're honest about why web apps are popular, it's because
deployment is so easy.  But more interestingly, if we're honest about how the
web is being used, it's being used to provide essentially sandbox applications
of some kind, so if an application could be compiled to bytecode and
distributed as a `web app' that simply runs (slower) inside the sandbox all
the time, and if we could distribute these in a simple way (that has all the
easiness factor of the web)...

20090709:202629:Details details details...

I think we have an API decision.  After reading about various event-based
architechures (particularly continuation based systems as used in Scheme) and
worrying that these seemed nice but did not obviously lend themselves to the
uses I intended to make possible, I think I have reconciled the issues.  

One possibility is to switch to a completely event-driven system.  Connections
could then be implemented by having a syscall (`connect') to automatedly
register any node as a handler of your event (which will often serve, when
fired, to send all handlers a command which can be processed as a function
call).  

This could be placed on the level of the system itself by having all
nodes register their public functions as `available handlers' and then having
any user fire the appropriate event when desired, but this has the problem of
having to setup the interface on the fly, whereas IPC can be made more
efficient if we declare at the outset that we want to talk to the ATA driver,
set up shared memory at the beginning and then use it when necessary, as the
setup is a potential bottleneck, especially for one-off things, whereas the
cost of having many stale connections open at one time is meant to be
minimal.  

However, if registering as an event handler allocates space for allowing
transfer of event-related data at the outset, then this is similar to
allocating space for connection data anyways.  Other desirable operations may
readily be simulated with events as well, for example splicing a connection
can be accomplished by the splicer's registering as a handler to the desired
`connection' event.

Connections are good when there is a central server (e.g. a ATA driver) that
you want to tell start some task and return the answer to you, but not so much
for other things, like keyboard input, which you want to be accessible to
multiple programs and would thus be best broadcast as an event.  

??????

20090817:011230:Practical Thoughts

All told, we'd like a decently clean architecture underlying the end-product,
but given we have an idea of the functionality and perhaps just want to
ensure longevity (or something) by making the base API both maximally
straightforward and maximally expressive, we'll run with the current idea of
using events and connections and running continuations on virtual processors
and so on and stop quibbling about the exact theoretical details.  This will
work, and we can clean up later if it comes to that.  

There are pros and cons, and there is room for endless weighing and modifying
the various abstractions heretofore mentioned, but the time to actually
implement anything grows limited and so we will worry less about such matters
(fun though they be) until we have an actual product and work on honest
production from now until October.  

To this end, consider the motivating example we have held throughout: 

We have a text editor that exposes its interface to the user via a shell.
The text editor publishes its interface descriptor which is then read by the
shell, which sets up its list of valid commands and variables accordingly, and
establishes a (privileged) connection with the software.  

If, for example, the user has been editing in hex mode and wishes to send his
file as a packet, then the shell can be made to import the TCP/IP stack's
interface by some `import' command, which will allow the use of its commands
(e.g. 'net.send_UDP(TextEditor.rawData, 123.456.789.0)') for this purpose.  

What goes on behind this is the setting up of connections (which allow two-way
communication between nodes) and using the connections by firing corresponding
events (e.g. `data received on connection 267', etc.).  

More details can be fleshed out later, but this is the gist of it, and makes
it somewhat clear that the abstractions of events and two-way connections will
likely suffice, and so our goal now is to work out APIs for these and then to
implement them.  

124604

20090818:181932:A Refresher in the Details and a Plan for Victory

-Details: 

Need to find and update this with: 
--Kernel stack location (physmem (if it matters) and vmem): 
      0x90000 in physmem, 0xC0000000 in vmem?  
--Kernel location (physmem and vmem)
      Anywhere in physmem (probably 0x10000 onwards), 0xC0000000 in vmem.  
--Kernel struct allocater's space (in vmem)
      After kernel (rest of upper vmem).  (This may include the physmem mgr).  

Also, just for kicks, let us remind ourselves: 

--Physical allocator's resources and functions (PT/PD locations and
self-reference handling in particular)
--IVT/IDT location (I seem to recall there was a problem with this)

-Plan: 

There is a high-level plan and a low-level plan.  The low-level plan is
similar to (but more final than) the thing we've been talking about for a long
time, namely the specific form of the kernel API.  We already have an idea
what this must look like, but we'll spend the next day or so nailing down the
details so that we can at least finish coding this by October.  

--Kernel API: 
   Primitives: 
      event_t
         int UID;
	 continuation_t *handlers;

      connection_t
         int UID;
	 event_t *rcv;
	 event_t *send;
	 void *rx_buf_start;
	 void *tx_buf_start;
	 int rx_buf_size;
	 int tx_buf_size;
	 
      node_t
	 int UID;
	 pagedir_t *page_dir;
	 
      continuation_t
         int UID;
	 tss_t TSS;
         node_t *node;
	 int EIP;

      vp_t
         int UID;
         node_t current;


   Functions: 
   (Node-related): 
      mk_node
      dump_node
   (Continuation-related): 
      mk_continuation
      throw
   (Event-related): 
      register_as_handler
      remove_handler
      fire
   (VP-related): 
      mk_vp
      suspend_vp
      dump_vp
   (Connection-related): 
      connect
      disconnect
      send

The high-level plan is the interface-descriptor language that will (hopefully)
be most often used over the connections and events of the low-level API.  This
should always be accessible from a shell, but should also be coverable with a
GUI frontend to taste (e.g. I should be able to have a slider setting a value
by, when the slider is moved, the IDL version of `change this value to that'
is sent across a connection from the GUI node to the relevant running node,
but also one should be able to, knowing the appropriate variable names and
such, be able to open a shell, connect it to the relevant node, and change the
value programmatically (which is obviously more often useful in a script than
by hand, but the principle should remain)).  This requires a rather carefully
thought-out high-level API which will comprise the Toast IDL, and which is the
most crucial part of the design.  Significantly, it needs to be
ultra-expressive, as the people who don't want to write in assembler (or some
specifically-crafted HLL) will have to be able to work entirely with it (or
else there is a risk of everyone using a personalized proprietary IDL, which
entirely defeats the purpose).  This will take some consideration and effort,
but we'll start with the following very simple OOP-inspired template for A.0.1
and take it from there (note for instance that `set' and `get' are redundant
with `call' because of accessor functions), considering that perhaps most
significant is whatever scripting language/GUI builder falls out on top of
this.  .

--IDL:
   Functions
      set
         sets the variable with the given name to the given value
      call
         calls the given function
      get
         returns the value associated with the given variable name
       
21:163938

20090822:0045??:Going

hh now triple faults on boot, seemingly when we try to do anything with
vidmem.  

mov eax,[ModeInfo_PhysBasePtr+BASE]
mov [eax],dword 0xFFFFFFFF

fails, whereas

moc eax,dword 0xF8000000
mov [eax],dword 0xFFFFFFFF

has the correct effect.  

What?  

005141

20090822:011611:Going

The following (sloppily written) code prints out eax backwards when in segmented pmode

        ;; 20090822 TESTING CODE
        mov eax,0x89ABCDEF
        mov ecx,0
.ello:
        mov edx,eax
        and edx,0xF
        mov bl,[adf+edx]
        mov [0xb8000+2*ecx],bl
        mov [0xb8001+2*ecx],byte 0x0F
        shr eax,4
        inc ecx
        cmp ecx,8
        jb .ello

asd:    jmp asd

adf:    dd '0123456789ABCDEF'
        ;; END 20090822 TESTING CODE

...

AHA!  When we change 0x89ABCDEF to [ModeInfo_PhysBasePtr+BASE] we get the
output 000000DF (i.e. 0xFD000000)!  

But why then did printing to [0xF8000000] work (AND give the top left pixel on
the screen)?

Investigation is forthcoming.  

...

When we run with BASE-4 we get 0x00000000
When we run with BASE+4 we get 0xFD15F900

which are plausible values for ModeInfo_DirectColorModeInfo and
ModeInfo_OffScreenMemOffset  respectively...  Maybe...

So I doubt there's been something shifted in some annoying way, at any rate.  

012727


20090822:013522:Going

Now we can plot pixels to the screen, which is good, and now we don't have any
stray 0xF80's or 0xF8000000's or any such things hard-coded in (hopefully!),
so this should work consistently across different machines now...

In fact, it even gets to kmain (where kmain is blank) OK now!  We've made
progress (back to where we were at 20090404, apparently)!  

And we can again print!  

--OUT
esp: 8FFE0
vidstart: FD000000
HELLO PAGED WORLD!
--END OUT

Now we've got to get the hh paging set up correctly...  (As is unsurprising,
uncommenting the call to paging_init in kernel.c causes a triple fault.)  

014341


20090822:032014:Going

IDT/IVT seems to be broken--pressing keys leads to triple fault...

032036


20090822:210823:Going insane

There seems to be a problem with PIC remapping now.  What?  

...

Seems it was not a problem with PIC remapping (was disassembling in 16-bit
mode--OOPS) but rather with something else.  Even adding a nop anywhere in
kinit.asm causes a triple fault, with the faulting address listed as what
appears to be somewhere in the `flush' section: 

qemu: fatal: triple fault
EAX=00088299 EBX=0000c000 ECX=c0000001 EDX=f03ff003
ESI=ffff7c2b EDI=f0000010 EBP=00000001 ESP=0008fff4
EIP=c00000a7 EFL=00000002 [-------] CPL=0 II=0 A20=1 SMM=0 HLT=0
ES =0010 00000000 ffffffff 00cf9300
CS =0008 00000000 ffffffff 00cf9a00
SS =0010 00000000 ffffffff 00cf9300
DS =0010 00000000 ffffffff 00cf9300
FS =0010 00000000 ffffffff 00cf9300
GS =0010 00000000 ffffffff 00cf9300
LDT=0000 00000000 0000ffff 00008200
TR =0000 00000000 0000ffff 00008b00
GDT=     c0000059 00000017
IDT=     00000000 000003ff
CR0=e0000011 CR2=00488a99 CR3=00009000 CR4=00000000
CCS=00088299 CCD=000882f2 CCO=ADDB
FCW=037f FSW=0000 [ST=0] FTW=00 MXCSR=00001f80
FPR0=0000000000000000 0000 FPR1=0000000000000000 0000
FPR2=0000000000000000 0000 FPR3=0000000000000000 0000
FPR4=0000000000000000 0000 FPR5=0000000000000000 0000
FPR6=0000000000000000 0000 FPR7=0000000000000000 0000
XMM00=00000000000000000000000000000000 XMM01=00000000000000000000000000000000
XMM02=00000000000000000000000000000000 XMM03=00000000000000000000000000000000
XMM04=00000000000000000000000000000000 XMM05=00000000000000000000000000000000
XMM06=00000000000000000000000000000000 XMM07=00000000000000000000000000000000
Aborted

Whereas

ndisasm -b32 kernel.bin |head -n 100

Gives: 

00000000  58                pop eax
00000001  A3F60200C0        mov [0xc00002f6],eax
00000006  0F0115710000C0    lgdt [dword 0xc0000071]
0000000D  EA140000C00800    jmp dword 0x8:0xc0000014
00000014  66B81000          mov ax,0x10
00000018  8ED8              mov ds,ax
0000001A  8EE0              mov fs,ax
0000001C  8EE8              mov gs,ax
0000001E  8EC0              mov es,ax
00000020  8ED0              mov ss,ax
00000022  EA290000C00800    jmp dword 0x8:0xc0000029
00000029  E849000000        call dword 0x77
0000002E  B0FF              mov al,0xff
00000030  E621              out 0x21,al
00000032  E6A1              out 0xa1,al
00000034  0F011DE00100C0    lidt [dword 0xc00001e0]
0000003B  FB                sti
0000003C  B101              mov cl,0x1
0000003E  B401              mov ah,0x1
00000040  D2E4              shl ah,cl
00000042  80F4FF            xor ah,0xff
00000045  E421              in al,0x21
00000047  20E0              and al,ah
00000049  E621              out 0x21,al
0000004B  90                nop
0000004C  FF35F60200C0      push dword [dword 0xc00002f6]
00000052  E8856D0000        call dword 0x6ddc
00000057  EBFE              jmp short 0x57
00000059  0000              add [eax],al
0000005B  0000              add [eax],al
0000005D  0000              add [eax],al
0000005F  0000              add [eax],al
00000061  FF                db 0xFF
00000062  FF00              inc dword [eax]
00000064  0000              add [eax],al
00000066  9ACF00FFFF0000    call dword 0x0:0xffff00cf
0000006D  0092CF001700      add [edx+0x1700cf],dl
00000073  59                pop ecx
00000074  0000              add [eax],al
00000076  C050B011          rcl byte [eax-0x50],0x11
0000007A  E620              out 0x20,al
0000007C  B011              mov al,0x11
0000007E  E6A0              out 0xa0,al
00000080  B020              mov al,0x20
00000082  E621              out 0x21,al
00000084  B028              mov al,0x28
00000086  E6A1              out 0xa1,al
00000088  B004              mov al,0x4
0000008A  E621              out 0x21,al
0000008C  B002              mov al,0x2
0000008E  E6A1              out 0xa1,al
00000090  B001              mov al,0x1
00000092  E621              out 0x21,al
00000094  B001              mov al,0x1
00000096  E6A1              out 0xa1,al
00000098  58                pop eax
00000099  C3                ret
0000009A  60                pushad
0000009B  668CD8            mov ax,ds
0000009E  50                push eax
0000009F  66B81000          mov ax,0x10
000000A3  8ED8              mov ds,ax
000000A5  8EC0              mov es,ax
000000A7  8EE0              mov fs,ax
000000A9  8EE8              mov gs,ax
000000AB  E8856C0000        call dword 0x6d35
000000B0  58                pop eax
000000B1  8ED8              mov ds,ax
000000B3  8EC0              mov es,ax
000000B5  8EE0              mov fs,ax
000000B7  8EE8              mov gs,ax
000000B9  61                popad
000000BA  81C408000000      add esp,0x8
000000C0  FB                sti
000000C1  CF                iretd
000000C2  FA                cli
000000C3  6A00              push byte +0x0
000000C5  6A00              push byte +0x0
000000C7  EBD1              jmp short 0x9a
000000C9  FA                cli
000000CA  6A00              push byte +0x0
000000CC  6A01              push byte +0x1
000000CE  EBCA              jmp short 0x9a
000000D0  FA                cli
000000D1  6A00              push byte +0x0
000000D3  6A02              push byte +0x2
000000D5  EBC3              jmp short 0x9a
000000D7  FA                cli
000000D8  6A00              push byte +0x0
000000DA  6A03              push byte +0x3
000000DC  EBBC              jmp short 0x9a
000000DE  FA                cli
000000DF  6A00              push byte +0x0
000000E1  6A04              push byte +0x4
000000E3  EBB5              jmp short 0x9a
000000E5  FA                cli
000000E6  6A00              push byte +0x0
000000E8  6A05              push byte +0x5
000000EA  EBAE              jmp short 0x9a
000000EC  FA                cli

So if EIP=0xC000000A7 corresponds to instruction 0xA7 above, then the
problematic assembler would appear to be: 

flush:
        mov ax,data_selector
        mov ds,ax
        mov fs,ax

But this is before the added nop.  What?  Does this mean adding an extra
instruction throws off some alignments?  Or that the space we've left is too
small and there is 

But also weird is that when we include the auxilliary files in the orders: 


%include 'init/isr.asm'
%include 'init/pic.asm'
%include 'init/idt.asm'

or 

%include 'init/pic.asm'
%include 'init/isr.asm'
%include 'init/idt.asm'

it works, whereas the order

%include 'init/isr.asm'
%include 'init/idt.asm'
%include 'init/pic.asm'

does not.  WHAT!?  

This strongly suggests an alignment issue, but of what?  And why then does
adding 2 or 4 or 16 nops not work?  While we're thinking, we can try some
things like adding nops in clever places to bisect where the alignment is
important (if anywhere).  We begin by putting the order as 

%include 'init/pic.asm'
%include 'init/isr.asm'
%include 'init/idt.asm'

-At start of isr.asm: OK (!?)

Putting it anywhere in the pic_remap routine seems to kill it, whereas
anywhere after the ret for this routine seems to survive.  What?  

234531

20090823:030654:Going

Removing instructions seems never to hurt, though I wonder if it can be a size
issue, as removing the reserved space on the end for the stack never seems to
do anything...  

030748


20090823:225943:Going

This is strange.  QEMU claims the faulting address is 0xC00000A7, so we get a
disassembly of what it thinks is going on at and around this address, as well
as a hexdump of the actual memory here: 

(gdb) disassemble 0xc0000020 0xc00000f0
Dump of assembler code from 0xc0000020 to 0xc00000f0:
0xc0000020:     add    %bl,-0xff31(%edx)
0xc0000026:     add    %al,(%eax)
0xc0000028:     add    %dl,0x1700cf(%ebx)
0xc000002e:     adc    $0x0,%al
0xc0000030:     add    %al,%al
0xc0000032:     mov    $0x10,%ax
0xc0000036:     mov    %eax,%ds
0xc0000038:     mov    %eax,%fs
0xc000003a:     mov    %eax,%gs
0xc000003c:     mov    %eax,%es
0xc000003e:     mov    %eax,%ss
0xc0000040:     ljmp   $0x8,$0xc0000047
0xc0000047:     call   0xc0000076
0xc000004c:     mov    $0xff,%al
0xc000004e:     out    %al,$0x21
0xc0000050:     out    %al,$0xa1
0xc0000052:     lidtl  0xc00001df
0xc0000059:     sti
0xc000005a:     mov    $0x1,%cl
0xc000005c:     mov    $0x1,%ah
0xc000005e:     shl    %cl,%ah
0xc0000060:     xor    $0xff,%ah
0xc0000063:     in     $0x21,%al
0xc0000065:     and    %ah,%al
0xc0000067:     out    %al,$0x21
0xc0000069:     pushl  0xc00002f5
0xc000006f:     call   0xc0002de5
0xc0000074:     jmp    0xc0000074
0xc0000076:     push   %eax
0xc0000077:     mov    $0x11,%al
0xc0000079:     out    %al,$0x20
0xc000007b:     mov    $0x11,%al
0xc000007d:     out    %al,$0xa0
0xc000007f:     mov    $0x20,%al
0xc0000081:     out    %al,$0x21
0xc0000083:     mov    $0x28,%al
0xc0000085:     out    %al,$0xa1
0xc0000087:     mov    $0x4,%al
0xc0000089:     out    %al,$0x21
0xc000008b:     mov    $0x2,%al
0xc000008d:     out    %al,$0xa1
0xc000008f:     mov    $0x1,%al
0xc0000091:     out    %al,$0x21
0xc0000093:     mov    $0x1,%al
0xc0000095:     out    %al,$0xa1
0xc0000097:     pop    %eax
0xc0000098:     ret
0xc0000099:     push   %esi
0xc000009a:     inc    %ebp
0xc000009b:     push   %ebx
0xc000009c:     inc    %ecx
0xc000009d:     add    %al,(%edx)
0xc000009f:     xchg   %eax,%edi
---Type <return> to continue, or q <return> to quit---
0xc00000a0:     (bad)
0xc00000a1:     add    %al,%al
0xc00000a3:     add    %al,(%eax)
0xc00000a5:     add    %al,(%eax)
0xc00000a7:     flds   0x400800(%eax)
0xc00000ad:     add    %al,(%ecx)
0xc00000af:     xchg   %eax,%edi
0xc00000b0:     (bad)
0xc00000b1:     add    %al,%al
0xc00000b3:     xchg   %eax,%edi
0xc00000b4:     (bad)
0xc00000b5:     add    %al,%al
0xc00000b7:     mov    $0x82,%al
0xc00000b9:     add    %al,%al
0xc00000bb:     or     %al,(%eax)
0xc00000bd:     add    %al,(%eax)
0xc00000bf:     sti
0xc00000c0:     iret
0xc00000c1:     cli
0xc00000c2:     push   $0x0
0xc00000c4:     push   $0x0
0xc00000c6:     jmp    0xc0000099
0xc00000c8:     cli
0xc00000c9:     push   $0x0
0xc00000cb:     push   $0x1
0xc00000cd:     jmp    0xc0000099
0xc00000cf:     cli
0xc00000d0:     push   $0x0
0xc00000d2:     push   $0x2
0xc00000d4:     jmp    0xc0000099
0xc00000d6:     cli
0xc00000d7:     push   $0x0
0xc00000d9:     add    %eax,(%ecx)
0xc00000db:     adc    %al,(%ecx)
0xc00000dd:     adc    %eax,(%ecx)
0xc00000df:     adc    (%ecx),%al
0xc00000e1:     add    (%ecx),%eax
0xc00000e3:     adc    (%ecx),%eax
0xc00000e5:     adc    $0x1,%al
0xc00000e7:     adc    $0x16010501,%eax
0xc00000ec:     add    %edx,(%edi)
0xc00000ee:     add    %ebx,(%eax)
End of assembler dump.
(gdb) x/72b 0xc0000090
0xc0000090:     0x01    0xe6    0x21    0xb0    0x01    0xe6    0xa1    0x58
0xc0000098:     0xc3    0x56    0x45    0x53    0x41    0x00    0x02    0x97
0xc00000a0:     0x82    0x00    0xc0    0x00    0x00    0x00    0x00    0xd9
0xc00000a8:     0x80    0x00    0x08    0x40    0x00    0x00    0x01    0x97
0xc00000b0:     0x82    0x00    0xc0    0x97    0x82    0x00    0xc0    0xb0
0xc00000b8:     0x82    0x00    0xc0    0x08    0x00    0x00    0x00    0xfb
0xc00000c0:     0xcf    0xfa    0x6a    0x00    0x6a    0x00    0xeb    0xd1
0xc00000c8:     0xfa    0x6a    0x00    0x6a    0x01    0xeb    0xca    0xfa
0xc00000d0:     0x6a    0x00    0x6a    0x02    0xeb    0xc3    0xfa    0x6a
(gdb)

However, if we compare this with the ndisasm of kernel.bin near this area: 

00000040  EA470000C00800    jmp dword 0x8:0xc0000047
00000047  E82A000000        call dword 0x76
0000004C  B0FF              mov al,0xff
0000004E  E621              out 0x21,al
00000050  E6A1              out 0xa1,al
00000052  0F011D0A0200C0    lidt [dword 0xc000020a]
00000059  B101              mov cl,0x1
0000005B  B401              mov ah,0x1
0000005D  D2E4              shl ah,cl
0000005F  80F4FF            xor ah,0xff
00000062  E421              in al,0x21
00000064  20E0              and al,ah
00000066  E621              out 0x21,al
00000068  FF35200300C0      push dword [dword 0xc0000320]
0000006E  E8B22D0000        call dword 0x2e25
00000073  F4                hlt
00000074  EBFE              jmp short 0x74
00000076  50                push eax
00000077  B011              mov al,0x11
00000079  E620              out 0x20,al
0000007B  B011              mov al,0x11
0000007D  E6A0              out 0xa0,al
0000007F  B020              mov al,0x20
00000081  E621              out 0x21,al
00000083  B028              mov al,0x28
00000085  E6A1              out 0xa1,al
00000087  B004              mov al,0x4
00000089  E621              out 0x21,al
0000008B  B002              mov al,0x2
0000008D  E6A1              out 0xa1,al
0000008F  B001              mov al,0x1
00000091  E621              out 0x21,al
00000093  B001              mov al,0x1
00000095  E6A1              out 0xa1,al
00000097  58                pop eax
00000098  C3                ret
00000099  60                pushad
0000009A  668CD8            mov ax,ds
0000009D  50                push eax
0000009E  66B81000          mov ax,0x10
000000A2  8ED8              mov ds,ax
000000A4  8EC0              mov es,ax
000000A6  8EE0              mov fs,ax
000000A8  8EE8              mov gs,ax
000000AA  E8CA2C0000        call dword 0x2d79
000000AF  58                pop eax
000000B0  8ED8              mov ds,ax
000000B2  8EC0              mov es,ax
000000B4  8EE0              mov fs,ax
000000B6  8EE8              mov gs,ax
000000B8  61                popad
000000B9  81C408000000      add esp,0x8
000000BF  FB                sti
000000C0  CF                iretd
000000C1  FA                cli
000000C2  6A00              push byte +0x0
000000C4  6A00              push byte +0x0
000000C6  F4                hlt
000000C7  EBD0              jmp short 0x99
000000C9  FA                cli
000000CA  6A00              push byte +0x0
000000CC  6A01              push byte +0x1
000000CE  F4                hlt
000000CF  EBC8              jmp short 0x99
000000D1  FA                cli
000000D2  6A00              push byte +0x0
000000D4  6A02              push byte +0x2
000000D6  F4                hlt
000000D7  EBC0              jmp short 0x99
000000D9  FA                cli
000000DA  6A00              push byte +0x0
000000DC  6A03              push byte +0x3
000000DE  F4                hlt
000000DF  EBB8              jmp short 0x99
000000E1  FA                cli
000000E2  6A00              push byte +0x0
000000E4  6A04              push byte +0x4
000000E6  F4                hlt
000000E7  EBB0              jmp short 0x99
000000E9  FA                cli
000000EA  6A00              push byte +0x0
000000EC  6A05              push byte +0x5
000000EE  F4                hlt
000000EF  EBA8              jmp short 0x99
000000F1  FA                cli
000000F2  6A00              push byte +0x0
000000F4  6A06              push byte +0x6
000000F6  F4                hlt

and the corresponding hexdump: 

0000090 e601 b021 e601 58a1 60c3 8c66 50d8 b866
00000a0 0010 d88e c08e e08e e88e 8ae8 002c 5800
00000b0 d88e c08e e08e e88e 8161 08c4 0000 fb00
00000c0 facf 006a 006a d1eb 6afa 6a00 eb01 faca
00000d0 006a 026a c3eb 6afa 6a00 eb03 fabc 006a
00000e0 046a b5eb 6afa 6a00 eb05 faae 006a 066a
00000f0 a7eb 6afa 6a00 eb07 faa0 086a 9beb 6afa

We note that: 

0000090 e601 b021 e601 58a1 60c3 8c66 50d8 b866
00000a0 0010 d88e c08e e08e e88e 8ae8 002c 5800
00000b0 d88e c08e e08e e88e 8161 08c4 0000 fb00
00000c0 facf 006a 006a d1eb 6afa 6a00 eb01 faca
00000d0 006a 026a c3eb 6afa 6a00 eb03 fabc 006a
00000e0 046a b5eb 6afa 6a00 eb05 faae 006a 066a
00000f0 a7eb 6afa 6a00 eb07 faa0 086a 9beb 6afa

Or, more usefully (though difficult to come by--the manpage on hexdump's -e
option was a bit of a struggle, though quite complete and helpful once you
understand the idea):

(20090823:231823 zoom@Ziggy ~/toast/source/hh)>hexdump -s 0x90 -v -n 64 -e '"0x%04_ax:  "' -e '8/1 "%02x "' -e '"\n"'  kernel.bin
0x0090:  01 e6 21 b0 01 e6 a1 58
0x0098:  c3 60 66 8c d8 50 66 b8
0x00a0:  10 00 8e d8 8e c0 8e e0
0x00a8:  8e e8 e8 8a 2c 00 00 58
0x00b0:  8e d8 8e c0 8e e0 8e e8
0x00b8:  61 81 c4 08 00 00 00 fb
0x00c0:  cf fa 6a 00 6a 00 eb d1
0x00c8:  fa 6a 00 6a 01 eb ca fa

versus

0xc0000090:     0x01    0xe6    0x21    0xb0    0x01    0xe6    0xa1    0x58
0xc0000098:     0xc3    0x56    0x45    0x53    0x41    0x00    0x02    0x97
0xc00000a0:     0x82    0x00    0xc0    0x00    0x00    0x00    0x00    0xd9
0xc00000a8:     0x80    0x00    0x08    0x40    0x00    0x00    0x01    0x97
0xc00000b0:     0x82    0x00    0xc0    0x97    0x82    0x00    0xc0    0xb0
0xc00000b8:     0x82    0x00    0xc0    0x08    0x00    0x00    0x00    0xfb
0xc00000c0:     0xcf    0xfa    0x6a    0x00    0x6a    0x00    0xeb    0xd1
0xc00000c8:     0xfa    0x6a    0x00    0x6a    0x01    0xeb    0xca    0xfa
0xc00000d0:     0x6a    0x00    0x6a    0x02    0xeb    0xc3    0xfa    0x6a

has issues starting at 0xC0000099.  Reformatting: 

kernel.bin's: 

0x0090:  01 e6 21 b0 01 e6 a1 58
0x0098:  c3 60 66 8c d8 50 66 b8
0x00a0:  10 00 8e d8 8e c0 8e e0
0x00a8:  8e e8 e8 8a 2c 00 00 58
0x00b0:  8e d8 8e c0 8e e0 8e e8
0x00b8:  61 81 c4 08 00 00 00 fb
0x00c0:  cf fa 6a 00 6a 00 eb d1
0x00c8:  fa 6a 00 6a 01 eb ca fa

versus qemu's: 

0x0090:  01 e6 21 b0 01 e6 a1 58
0x0098:  c3 56 45 53 41 00 02 97
0x00a0:  82 00 c0 00 00 00 00 d9
0x00a8:  80 00 08 40 00 00 01 97
0x00b0:  82 00 c0 97 82 00 c0 b0
0x00b8:  82 00 c0 08 00 00 00 fb
0x00c0:  cf fa 6a 00 6a 00 eb d1
0x00c8:  fa 6a 00 6a 01 eb ca fa

differ from 0x99 to 0xba (which interestingly, in the kernel.bin disassembly,
corresponds pretty much exactly to: 

00000099  60                pushad
0000009A  668CD8            mov ax,ds
0000009D  50                push eax
0000009E  66B81000          mov ax,0x10
000000A2  8ED8              mov ds,ax
000000A4  8EC0              mov es,ax
000000A6  8EE0              mov fs,ax
000000A8  8EE8              mov gs,ax
000000AA  E88A2C0000        call dword 0x2d39
000000AF  58                pop eax
000000B0  8ED8              mov ds,ax
000000B2  8EC0              mov es,ax
000000B4  8EE0              mov fs,ax
000000B6  8EE8              mov gs,ax
000000B8  61                popad
000000B9  81C408000000      add esp,0x8

the general interrupt handler!  Though I suspect this is not the only
corrupted area.)  

At some point, this memory seems to be getting trashed, and I suspect it is
when we write the page tables.  But in any case the plan of attack now should
be to look for exactly when the trashing occurs.  For instance, we know it is
after boot, as the binary has it correct (and disassembles to the correct
thing as well).

The first obstruction is to find out where the code is before we enable
paging, but even before that, we'll just have a quick look by making it halt
just after paging is enabled and inspect the same region of memory then in
GDB: 

0xc0000090:     0x01    0xe6    0x21    0xb0    0x01    0xe6    0xa1    0x58
0xc0000098:     0xc3    0x56    0x45    0x53    0x41    0x00    0x02    0x97
0xc00000a0:     0x82    0x00    0xc0    0x00    0x00    0x00    0x00    0xd9
0xc00000a8:     0x80    0x00    0x08    0x40    0x00    0x00    0x01    0x97
0xc00000b0:     0x82    0x00    0xc0    0x97    0x82    0x00    0xc0    0xb0
0xc00000b8:     0x82    0x00    0xc0    0x08    0x00    0x00    0x00    0xfb
0xc00000c0:     0xcf    0xfa    0x6a    0x00    0x6a    0x00    0xeb    0xd1
0xc00000c8:     0xfa    0x6a    0x00    0x6a    0x01    0xeb    0xca    0xfa
0xc00000d0:     0x6a    0x00    0x6a    0x02    0xeb    0xc3    0xfa    0x6a

So it is wrong already by this point.  So we actually have to do some work,
but not that much.  boot.asm has the kernel loaded at 0x10000, so we should
just have to look at 0x10090 before (or even after, as there is still an
id-mapped chunk) paging is enabled.  Behold (from the same debugging session): 

(gdb) x/72b 0x10090
0x10090:        0x01    0xe6    0x21    0xb0    0x01    0xe6    0xa1    0x58
0x10098:        0xc3    0x56    0x45    0x53    0x41    0x00    0x02    0x97
0x100a0:        0x82    0x00    0xc0    0x00    0x00    0x00    0x00    0xd9
0x100a8:        0x80    0x00    0x08    0x40    0x00    0x00    0x01    0x97
0x100b0:        0x82    0x00    0xc0    0x97    0x82    0x00    0xc0    0xb0
0x100b8:        0x82    0x00    0xc0    0x08    0x00    0x00    0x00    0xfb
0x100c0:        0xcf    0xfa    0x6a    0x00    0x6a    0x00    0xeb    0xd1
0x100c8:        0xfa    0x6a    0x00    0x6a    0x01    0xeb    0xca    0xfa
0x100d0:        0x6a    0x00    0x6a    0x02    0xeb    0xc3    0xfa    0x6a
(gdb)  

Good.  Now we hlt earlier (before setting up the page tables at
all--i.e. after initizing VESA) and get: 

0x000083d2 in ?? ()
(gdb) x/72b 0x10090
0x10090:        0x01    0xe6    0x21    0xb0    0x01    0xe6    0xa1    0x58
0x10098:        0xc3    0x56    0x45    0x53    0x41    0x00    0x02    0x97
0x100a0:        0x82    0x00    0xc0    0x00    0x00    0x00    0x00    0xd9
0x100a8:        0x80    0x00    0x08    0x40    0x00    0x00    0x01    0x97
0x100b0:        0x82    0x00    0xc0    0x97    0x82    0x00    0xc0    0xb0
0x100b8:        0x82    0x00    0xc0    0x08    0x00    0x00    0x00    0xfb
0x100c0:        0xcf    0xfa    0x6a    0x00    0x6a    0x00    0xeb    0xd1
0x100c8:        0xfa    0x6a    0x00    0x6a    0x01    0xeb    0xca    0xfa
0x100d0:        0x6a    0x00    0x6a    0x02    0xeb    0xc3    0xfa    0x6a
(gdb)  

So still messed up...  Without initize VESA (i.e. hlt in the same place, but
initizeVESA line commented out)?  

0x000083cf in ?? ()
(gdb) x/72b 0x10090
0x10090:        0x01    0xe6    0x21    0xb0    0x01    0xe6    0xa1    0x58
0x10098:        0xc3    0x60    0x66    0x8c    0xd8    0x50    0x66    0xb8
0x100a0:        0x10    0x00    0x8e    0xd8    0x8e    0xc0    0x8e    0xe0
0x100a8:        0x8e    0xe8    0xe8    0x8a    0x2c    0x00    0x00    0x58
0x100b0:        0x8e    0xd8    0x8e    0xc0    0x8e    0xe0    0x8e    0xe8
0x100b8:        0x61    0x81    0xc4    0x08    0x00    0x00    0x00    0xfb
0x100c0:        0xcf    0xfa    0x6a    0x00    0x6a    0x00    0xeb    0xd1
0x100c8:        0xfa    0x6a    0x00    0x6a    0x01    0xeb    0xca    0xfa
0x100d0:        0x6a    0x00    0x6a    0x02    0xeb    0xc3    0xfa    0x6a
(gdb) 

We have a winner!  Now where did we go wrong.  Since we're in a debugging
mood, we just stick rets in various places in the initizeVESA function and
see: 

No VESA init (the correct version): 

0x000083d3 in ?? ()
(gdb) x/72b 0x10090
0x10090:        0x01    0xe6    0x21    0xb0    0x01    0xe6    0xa1    0x58
0x10098:        0xc3    0x60    0x66    0x8c    0xd8    0x50    0x66    0xb8
0x100a0:        0x10    0x00    0x8e    0xd8    0x8e    0xc0    0x8e    0xe0
0x100a8:        0x8e    0xe8    0xe8    0x8a    0x2c    0x00    0x00    0x58
0x100b0:        0x8e    0xd8    0x8e    0xc0    0x8e    0xe0    0x8e    0xe8
0x100b8:        0x61    0x81    0xc4    0x08    0x00    0x00    0x00    0xfb
0x100c0:        0xcf    0xfa    0x6a    0x00    0x6a    0x00    0xeb    0xd1
0x100c8:        0xfa    0x6a    0x00    0x6a    0x01    0xeb    0xca    0xfa
0x100d0:        0x6a    0x00    0x6a    0x02    0xeb    0xc3    0xfa    0x6a
(gdb)  

After just VESA info filled: 

0x000083d3 in ?? ()
(gdb) x/72b 0x10090
0x10090:        0x01    0xe6    0x21    0xb0    0x01    0xe6    0xa1    0x58
0x10098:        0xc3    0x60    0x56    0x45    0x53    0x41    0x00    0x02
0x100a0:        0x97    0x82    0x00    0xc0    0x00    0x00    0x00    0x00
0x100a8:        0xda    0x80    0x00    0x08    0x40    0x00    0x00    0x01
0x100b0:        0x97    0x82    0x00    0xc0    0x97    0x82    0x00    0xc0
0x100b8:        0xb0    0x82    0x00    0xc0    0x00    0x00    0x00    0xfb
0x100c0:        0xcf    0xfa    0x6a    0x00    0x6a    0x00    0xeb    0xd1
0x100c8:        0xfa    0x6a    0x00    0x6a    0x01    0xeb    0xca    0xfa
0x100d0:        0x6a    0x00    0x6a    0x02    0xeb    0xc3    0xfa    0x6a
(gdb)

After mode info filled: 

0x000083d3 in ?? ()
(gdb) x/72b 0x10090
0x10090:        0x01    0xe6    0x21    0xb0    0x01    0xe6    0xa1    0x58
0x10098:        0xc3    0x60    0x56    0x45    0x53    0x41    0x00    0x02
0x100a0:        0x97    0x82    0x00    0xc0    0x00    0x00    0x00    0x00
0x100a8:        0xda    0x80    0x00    0x08    0x40    0x00    0x00    0x01
0x100b0:        0x97    0x82    0x00    0xc0    0x97    0x82    0x00    0xc0
0x100b8:        0xb0    0x82    0x00    0xc0    0x00    0x00    0x00    0xfb
0x100c0:        0xcf    0xfa    0x6a    0x00    0x6a    0x00    0xeb    0xd1
0x100c8:        0xfa    0x6a    0x00    0x6a    0x01    0xeb    0xca    0xfa
0x100d0:        0x6a    0x00    0x6a    0x02    0xeb    0xc3    0xfa    0x6a
(gdb)

After set mode (all of VESA init complete): 

0x00008931 in ?? ()
(gdb) x/72b 0x10090
0x10090:        0x01    0xe6    0x21    0xb0    0x01    0xe6    0xa1    0x58
0x10098:        0xc3    0x56    0x45    0x53    0x41    0x00    0x02    0x97
0x100a0:        0x82    0x00    0xc0    0x00    0x00    0x00    0x00    0xd9
0x100a8:        0x80    0x00    0x08    0x40    0x00    0x00    0x01    0x97
0x100b0:        0x82    0x00    0xc0    0x97    0x82    0x00    0xc0    0xb0
0x100b8:        0x82    0x00    0xc0    0x08    0x00    0x00    0x00    0xfb
0x100c0:        0xcf    0xfa    0x6a    0x00    0x6a    0x00    0xeb    0xd1
0x100c8:        0xfa    0x6a    0x00    0x6a    0x01    0xeb    0xca    0xfa
0x100d0:        0x6a    0x00    0x6a    0x02    0xeb    0xc3    0xfa    0x6a
(gdb)

So it seems to get trashed twice--once by the vesa info filler and once by the
mode setter (and, while it is untouched by the mode info filler, perhaps
that's just because we're not looking at all memory).  

We now have an obvious course of action, which is to do what would seem to
eventually be necessary and put the actual kernel loading code into stage2
after the VESA work is done (being careful to store what info we need from the
VESA blocks before trashing it by loading the kernel).  

To get a handle on these things we run our earlier code (for printing out the
contents of variables in pmode with text-mode VESA) on eax = VESA_Info to get
(remembering that it prints backwards...): 0008097, and for Mode_Info: 0008297
(I'd better not get used to this reading backwards thing...).  This should be
out of the way of everything!  What else is messed with by VESAinit?  Maybe it
has something to do with this es:di thing (where we start the VESAinit
function with 


        push  cs
        pop   ds
        mov   ax,ds
        mov   es,ax

wihtout ever checking what cs is.  ... After getting the value we see:
00000008.  So is 08:8097, which works out to 8*10+8097 = 8117, and 8317
similarly, which is still not in the range of values we expect to be
affected...

But further, there is the mystery of why the mode-setting int changes
anything.  Ah--according to Ralf Brown int 10 with ax = 4f02 fills some `CRTC'
info at es:di under VBE3.  So if we have a VBE3 card (in QEMU as well as our
RHW testbed...?) then this may explain why stuff is getting modified, but not
in the range we're seeing.  

This is curious, and worth coming back to, but a good I think now moving the
loading code (which should be quite small) into stage2 and after the VESA
initization is fine, as it will need to happen anyways.  (Again, though, we
need to ensure to not lose the [ModeInfo_PhysBasePtr] value in the process.  

But this is a project for tomorrow, so bye for now.  

24:014727


20090824:111655:Schedule

Looking back, the two most horrendous debugging experiences of this project
were the PD 0x300/0xC00 mishap and this random trashing of memory.  Viewing
these as some kind of upper bound on the time needed to debug, it looks like I
can expect three to five days of solid work (as is available until just before
October) for each major milestone.  So it becomes relevant to consider which
of these remain: 

-Page-table remapping (code exists--should be easy)
    (20090825: Done)

-Kernel struct allocator (Hard, but mostly a frontend for the physmem mgr)
    (20090830: First version done)

-Ramdisk loading (code exists--should be OK) 
    (20090901: First version done)

-Userland/Syscalls (code exists, but this is an Intel thing, so be wary...)
    (20090903: All tricky parts are done)

-Multitasking (difficult--some code exists)

-IPC (also difficult--no code yet!).

And now we actually have a month to do just these, where our crude
approximation puts the ETA at 30 days and 36 are available.  .  

Go time.  

112219


20090824:150154:Moving the Kernel Loader into Stage 2

We've moved the kernel-loading code into stage two and got the vidmem pointer
out, albeit with a bit more difficulty with worrying about the +BASE and
whatnot, which I don't fully understand yet.  

At any rate, QEMU likes it fine and I can evidently receive interrupts and
such without a problem, but RHW triple faults.  As far as I have experimented,
it occurs well after paging is enabled, so further debugging is in order...  

Ah, I've left in a stray

mov eax,0xF00000000
mov [eax],0xFFFFFFFF

which explains that.  (RHW box has vidmem at 0xFD000000, QEMU has 0xF0000000.)

After fixing that...Success!  Keyboard input even works on RHW (not in QEMU
though).  

Cool.  On to paging now.  

151045

20090824:170842:On kalloc

Now we're in kernel land and tackling the idea of paging, and we need some
sort of free memory to play with at the outset (for a place to put the
paging-related structures and such), and we don't have this available to us
yet.  I suppose we are forced to map in some other blob of physical memory in
stage2 for this purpose...   

This works fine, though the page fault handler seems to be triggered
repeatedly forever when we get a single page fault?  Maybe this is the
end-of-interrupt thing we've heard about but never bothered to look
into/implement.  Something to do, eventually.  Until then, we can now try to
get paging working...

22????

20090825:130515:Paging

We now attempt to fix the paging problem.  So far, we have the following
mappings: 

paging_idmap((void *)(videoram), height*width*3, 1, 0);
paging_idmap((void *)K_STACK_PHYS, K_STACK_SIZE, 1, 0);
paging_mapto((void *)K_DATA_PHYS, K_DATA_SIZE, (void *)0xC1000000, 1, 0);
paging_mapto((void *)K_BASE_PHYS, K_SIZE, (void *)0xC0000000, 1, 0);

using the definitions: 

#define K_BASE_PHYS 0x10000
#define K_DATA_PHYS 0x30000
#define K_DATA_SIZE 0x400000
#define K_STACK_PHYS 0x60000
#define K_STACK_SIZE 0x3000
#define K_SIZE 0x400000

The physical address of the PD appears to be 0x46000 (as we've started the
kernel's data area in physical RAM at 0x30000, though this still seems a bit
excessive in terms of usage... we can try to cut down a bit by allocating
aligned blobs separately or something, but this is something to worry about
later.  

In the meanwhile, we inspect the physical memory situation through QEMU's
monitor (Ctrl+Alt+2 in QEMU).  This tells us that 

0x46000: 0x4A007
0x46C00: 0x4E007
0x46C10: 0x4C007

and...no mapping for the stack at...wait.  I AM STUPID!

We correct to

#define K_STACK_PHYS 0x80000
#define K_STACK_SIZE 0x10000

and it works.  Blah.  

131520


20090825:131706:Paging on RHW

Um, so, when I said `it works', I was talking about on QEMU.  I get infinite
page faults (better than triple faults at least!) when I run it on RHW...
We'll stick an asm("hlt"); into the handler to see what's going on.  

...

It says (I kid you not): 

PAGE FAULT: at 0xDA06C633 with error code

What?

What if we stick an asm("hlt"); in right after enabling paging?  

...

Same thing if we put it after the function return.  What if before
(i.e. immediately after reloading cr3)?  

...

Same.  !?!??!

Actually, maybe this means the page faulting it happening entirely before the
switch, e.g. when we set up the page tables or possibly even the monitor.
Time to stick in some hlts to bisect the location of the problem.  

...

Happens before the switch and before the imap stack reset

...

And after setting the PD physical address, i.e. durring the mapping
somewhere.  

Actually, if we put in a bunch of hlts and press a key after each one this
seems to act as a `continue' sort of thing.  So we seek to find out exactly
which mapping and which point in the mapping is at fault (and why it didn't
have a problem in QEMU).  

We swapped the order of mapping because the only time we got a difference
between QEMU and RHW is with vidmem hard-coded values, so we put vidmem
mapping third this time, thus: 

  asm("hlt");asm("hlt");
  prints("0 ");
  asm("hlt");asm("hlt");
  paging_idmap((void *)K_STACK_PHYS, K_STACK_SIZE, 1, 0);
  prints("1 ");
  asm("hlt");asm("hlt");
  paging_mapto((void *)K_DATA_PHYS, K_DATA_SIZE, (void *)0xC1000000, 1, 0);
  prints("2 ");
  asm("hlt");asm("hlt");
  paging_idmap((void *)(videoram), height*width*3, 1, 0);
  prints("3 ");
  asm("hlt");asm("hlt");
  paging_mapto((void *)K_BASE_PHYS, K_SIZE, (void *)0xC0000000, 1, 0);
  prints("4 ");
  asm("hlt");asm("hlt");

But now we get page faulting at 0x747065.  !?!??!

Let us look at the numbers for the others, just out of curiosity: 

Thing  | Faulting addr | Physical addr
=======================================
STACK  | 0x747065      | 0x80000
VIDMEM | 0xDA06C633    | 0xFD000000
DATA   | 0x8440B06     | 0x30000
KERNEL | 0x5B1F5FDB    | 0x10000

Very weird.  

171327


20090825:183814:Paging idiocy--the dangers of uninitialized memory

We narrowed down the page faulting source to the get_page function, and so,
just to make sure the issue is not something with accessing the arguments, we
place the following blob of code at the beginning of the function (though
after defining table_index): 

  print_hex_32((u32)(dir));prints(" 1\n");
  print_hex_32(make);prints(" 2\n");
  print_hex_32(address);prints(" 3\n");
  print_hex_32(table_index);prints(" 4\n");
  print_hex_32((u32)(dir->tables[table_index]));prints(" 5\n");
  print_hex_32((u32)(&(dir->tables[table_index]->pages[address%1024])));prints("6\n");

The output on QEMU: 

C1015000 1
1 2
C0000 3
300 4
0 5
0 6
...

The output on RHW: 

C1015000 1
1 2
C0000 3
300 4
5B1F5FDB 5
5B1F5FDB 6

Aha!  

There is some unitialized memory thing going on then...  

...

Wow.  Compare: 


  u32 mem_size = 0x10000000;
  u32 num_frames = mem_size/0x1000;
  frames_map = imap_create(num_frames);
  setm((u32 *)(frames_map->bitmap->bits), 0, num_frames);

  kernel_dir = (pagedir_t *)kmalloc_a(sizeof(pagedir_t));

  setm((u32 *)kernel_dir, 0, sizeof(pagedir_t));


with: 

void setm(u32 *start, u32 size, u32 val){
  u32 i;
  for(i = 0; i < size; i += 1){
    *(start + i) = val;
  }
}

OOPS: setm takes the value as its third argument and size as the second, and
NOT the other way around.  

So this will work on QEMU, as it will set 0 bytes to something, i.e. it will
not do anything, but all memory is zeroed anyways, whereas on RHW the memory
is all garbage.  (Though always the same garbage?  That is a bit odd.)  

Anyways, swapping the arguments, we get success (still) on QEMU, and on RHW,
we get success in the sense that the garbage now registers are zeros, and
...SUCCESS on RHW!

185606


20090826:181618:Kernel Struct Allocator

Now we come to the first thing requiring a block of honestly new code--the
struct allocator.  We reproduce from earlier the list of structs decided on
for the kernel API, though we want to make our code sufficiently general that
it can be generalized on a whim if needed.  

      event_t
         int UID;
	 continuation_t *handlers;

      connection_t
         int UID;
	 event_t *rcv;
	 event_t *send;
	 void *rx_buf_start;
	 void *tx_buf_start;
	 int rx_buf_size;
	 int tx_buf_size;
	 
      node_t
	 int UID;
	 pagedir_t *page_dir;
	 
      continuation_t
         int UID;
	 tss_t TSS;
         node_t *node;
	 int EIP;

      vp_t
         int UID;
         node_t current;

The obvious way of doing this would be to store each allocated struct in
its own fixed-size block (to make the `heap' management easy) indexed by an imap (to
make for easy freeing and allocating).

Hopefully the imap code is sufficiently general to handle this with no further
work, but we shall see.  

27:025005


20090827:040751:Allocator I

Perhaps that was actually really not that bad: 

#define KS_HEAP_BLOCK_SIZE 128
#define KS_HEAP_SIZE 0x20000000

typedef struct
{
  u32 start;
  imap_t *ks_imap
} ks_heap_t;

ks_heap_t *kheap;

void *ks_heap_alloc_block(ks_heap_t *heap){
  u32 idx = imap_set_next(heap->ks_imap);
  u32 address = idx * KS_HEAP_BLOCK_SIZE + heap->start;
  get_a_frame(get_page(address, 1, kernel_dir), 1, 0);
  return (void *)(address);
}

void *ks_heap_free_block(ks_heap_t *heap, u32 block_address){
  u32 idx = (block_address - heap->start)/KS_HEAP_BLOCK_SIZE;
  imap_clear(heap->ks_imap, idx);
}

void ks_heap_init(){
  kheap = (ks_heap_t *)(kmalloc(sizeof(ks_heap_t)));
  kheap->start = 0xC2000000;
  kheap->ks_imap = imap_create(KS_HEAP_SIZE / KS_HEAP_BLOCK_SIZE);
}

We'll have another pass through that just in case (code written at 0400 tends
to be dangerous, at any rate), but perhaps there was nothing to be scared of.
Of course, testing will be interesting, but tomorrow.  

040916

20090827:125220:Allocator testing

From the looks of it, using the block-size and heap-size we're using it takes
rather a long time to set up the imap, (probably just pushing things onto the
stack), so we look at a likely better way to write the imap: 

Keep track of the largest occupied index, and then push onto the stack exactly
those indices that are smaller than the maximum.  So, for example, if we only
allocate and never free, the stack never gets used.  

Or perhaps this is a silly idea, as then the worst-case freeing time is
somewhat terrible in the case of freeing the highest block, (as then we have
to search back down for the next lowest one), and if we want to store these
values we'd need to do so in an ordered way, i.e. allocating becomes a chore.

For the sake of something quick and dirty we can implement the idea and worry
a bit less about the possibility of an `attack' by allocating loads of
connections (or whatever) and then freeing all but the last one allocated (a
fast operation) and then freeing the last one, as the trouble can be limited
by limiting the resources allocated collectively by the children of a single
node (or something).  

We shall revisit this, though, as it is an interesting issue.  

Another thing to be careful of is that even if we limit the number of
resources allocated, we still want to be able to free intermediate physical
frames if, for example, someone allocates 1GB + epsilon of resources and then
frees all but the last bit, we want to be able to reclaim almost all but the
last bit in actual physical memory.  

Hmm...  Details, details, details.  

28:013945


20090830:183228:Allocator and Ramdisk

We've left the allocator hanging with the stupid imap algorithm used for the
physmem manager, as the algorithm is easily swappable later (though we do need
to swap it eventually, as the stupid algorithm is stupid).  

Now then, it's on to the ramdisk!  

We can readily stick in further load-from-floppy code into stage2 (now that
the weird `adding nops causes triple-fault' issue is gone) and this works
fine, but we now have an issue of not knowing exactly where on the floppy to
load from, and where into RAM to load to.  We've allocated some space at
0x30000 onwards for kernel structures, and from 0x80000 to 0x90000 for the
stack, and from 0x10000-0x20000 for the kernel itself.  We'll stick the
ramdisk at 0x60000 for now and deal with it later if things are getting
stepped on.  Note that we don't have to map it in to the page tables in
stage2 as long as we know where is it when we get to the actual kernel.  

We will also need to clean up this somewhat ad-hoc usage of RAM, noting that
as we are in pmode by the time we're setting up page tables we can pretty much
use whatever memory we like for things like the kernel structs and the stack,
whereas the kernel and ramdisk actually need to be loaded below the 1MB
(0x100000) mark, as they are put in place while still in 16-bit realmode.  

But for now we heedlessly bash on, as this should be easy to remedy when it
becomes an issue, and as everything is small at this stage we won't need to
worry overmuch.  

192627


20090830:193019:Ramdisk Issues

A further issue with locating the ramdisk is where do we put it on the floppy,
and how do we pass this information to the kernel?  

One approach that we shall be happy to try shortly is to put the ramdisk in
some fixed place far above the kernel, say sector 0x100 and then happily load
from there as needed.  

There is a kludgy but general approach as well to have the make script fix all
the values once it has compiled everything so it can see how big the binaries
end up, but this is a bit nasty.  

193434


20090831:171104:Ramdisk Insanity

When I said earlier that the loading from floppy code worked fine, I meant
that it caused no faults and everything else worked as normal after inserting
it, and not that I'd actually tested that the ramdisk was actually in place.
And in fact, looking with xp/10 0x20000 in the QEMU monitor (Ctrl+Alt+2 when
in QEMU), we got all zeros.  Actually, this was discovered last night, and
lots of fiddling with placement and whatnot didn't seem to fix it, so I went
to sleep rather annoyed.  

But today I realized that the make script would place the initrd.img at the
end of kernel.img, and because I presently just have a silly little 106-byte
test image in there, the final sector of the image wasn't filled.  And the
emulator will therefore not be able to read the final sector, (as part of it
extends to where the disk doesn't exist).  

Zero-padding the image remedies this just fine, and now we can see the image
as expected.  Whew.  

171656


20090901:015929:Ramdisk Working... Maybe...

After recompiling (maybe I was working off an old version?) rdgen.c and fixing
compatability problems (the rdgen struct had size before start and the
initrd.c struct had them reversed!) and general stupidity, the ramdisk seems
to be working.  More rigorous tests will be done in the future, but for now we
move on to userland!

020214


20090902:053909:Userland Homework

Looking at manuals and tutorials and forum posts about this, there is a lot of
very confusing information on usermode, particularly pertaining to the use of
a TSS and to the need for possibly multiple stack frames and such here, and I
think it would be useful to consolidate this all in an explanation of the
process here.  

Getting into usermode is not a problem as long as we carefully set up the
stack with some garbage so that iret handles everything for us, this will
work.  

Then, we're in usermode.  A program running decides to make a syscall and
issues an interrupt.  The processor (for whatever reason) immediately goes to
the TSS (some intel-specific struct which keeps an entry in the GDT) and sets
ss and esp according to the corresponding values there.  That is, the
processor sets up a stack for the kernel based on values stored for it, and
allows it to merrily execute whatever kernel code from the handler using this
stack.  

But suppose at the same time another process was running, and it also decides
to issue a syscall.  Now another `instance' of the kernel will be running
(either on another processor or as another set of time-slices on a single
processor), and if it is trying to use the same stack as the first one, it
will very likely either step on something or get stepped on.  

What this actually looks like is this: 

Time 1: Process 1's timeslice begins.  
     PL = 3
     TSS.esp = esp0
     esp = esp1

Time 2: Process 1 syscalled and gave control to the kernel
     PL = 0
     TSS.esp = irrelevant (we're in the kernel now, and any interrupts
     	       received now will be handled without automatic messing with the
     	       stack)
     esp = esp0

Time 3: The kernel did something and changed the stack
     PL = 0
     TSS.esp = irrelevant
     esp = esp0+1

Time 4: Kernel is preempted (or something) and Process 2's timeslice begins
     PL = 3
     TSS.esp = esp3
     esp = esp2

Time 5: Process 2 issues a syscall
     PL = 0
     TSS.esp = irrelevant
     esp = esp3

Time 6: Kernel does something
     PL = 0
     TSS.esp = irrelevant
     esp = esp3+1

So if process 2 had had TSS.esp = esp0 (the same TSS.esp as process 1), at
time 6 when the kernel messes with the stack, it would have changed [esp0] and
we got back to the thread that was preempted between times 3 and 4, the stack
would look different from how that thread left it, which is likely to mess
things up.  

Thus the kernel (if it wants to be preemptable) must have, for each running
task, a corresponding esp value that will be stuck into the TSS at the start
of any timeslice allocated to that task so that if during that timeslice the
task decides to syscall, the kernel will be able to run the handler under a
valid stack and not worry about collisions.  

So how does this TSS business actually work?  

The TSS is some huge struct defined in the specs as something or other, but
basically what we do is we include an entry in the GDT of the form: 

0-15:  low 16 bits of the pointer to the top of the TSS
16-31: low 16 bits of the pointer to the bottom of the TSS
32-39: next 8 bits of the pointer to the bottom of the TSS
40:    present bit
41-42: privelege level (0-3)
43:    1
44:    code/data (1 = code, 0 = data)
45:    Can lower privilege levels execute this segment
46:    readable/writable (Data: 1 = readable, 0 = nothing, Code: 1 = Writable,
       0 = Read-only)
47:    Dirty
48:    Granularity (0 = 1-byte blocks, 1 = 4KiB blocks)
49:    Bits (1 = 32 bit, 0 = 16 bit)
50:    0
51:    0
52-55: next 4 bits of the pointer to the top of the TSS
56-63: last 8 bits of the pointer to the bottom of the TSS

0-15:  low 16 bits of the pointer to the top of the TSS
16-31: low 16 bits of the pointer to the bottom of the TSS
32-39: next 8 bits of the pointer to the bottom of the TSS
40:    1  (present)
41-42: 00 (ring 0)
43:    0  (???)
44:    1  (code) (why?)
45:    0  (only ring 0 can execute)
46:    0  (read-only)
47:    1  (accessed) (why?)
48:    0  (1-byte granularity)
49:    1  (32-bit)
50:    0
51:    0
52-55: next 4 bits of the pointer to the top of the TSS
56-63: last 8 bits of the pointer to the bottom of the TSS


There remains the issue of how do we fill out this entry in the assembly.  

Evidently what we shall do is to fill in as much as we can by hand and then,
after stage2 is done and we're upstairs we fill in the final entry (using
code) with the address of a pre-allocated block of memory in the kernel for
the TSS.  

Once we do this we have to 

ltr ax

where ax is set to (offset of TSS in GDT) | (Requested privilege level = 3).  

(This is likely going to be 8*5 | 3 = 0x2B.)  

We can then pass this address to the kernel, where we can associate it with a
C pointer which we can use to manipulate it properly and take it to town from
there.

Sounds like a plan.  

095222


20090902:110150:TSS Stage 1

After doing the aforementioned, we load up QEMU and check in the monitor: 

(qemu) info registers
...
TR =002b c0000360 000003c8 c040e900
GDT=     c000004b 0000002f
...

(qemu) x/12 0xc000004b

c000004b: 0x00000000 0x00000000 0x0000ffff 0x00cf9a00
c000005b: 0x0000ffff 0x00cf9300 0x0000ffff 0x00cffa00
c000006b: 0x0000ffff 0x00cff200 0x036003c8 0xc040eb00

Where the TSS entry in this GDT is therefore 0x036003c8 0xc040eb00

Reconstructing the address by first fixing endianness: 

c8 03 60 03 00 eb 40 c0

and then piecing back together from the above table: 

start: c0000360
end: ???003c8

which concurs with what we see when we pass the tss_start and tss_end as
parameters to the kernel (and we also see that the starting values of e9 40 were
not trashed either, except for e9->eb, i.e. read-only bit gets set...what?).  

There is concern that maybe the limit value is not supposed to be the high
value, particularly as this doesn't fit, but we'll see if there are any
problems.  

112644



20090902:183138:Usermode

All the scaffolding for getting into usermode seems to now be in place, but
the actual switch causes a triple fault (though admittedly QEMU reports that
this occurs in CPL=3).  More precisely: 

qemu: fatal: triple fault
EAX=00000246 EBX=0000d040 ECX=000000ff EDX=00000004
ESI=ffff7c2b EDI=000882d9 EBP=0008ffc4 ESP=0008ffc4
EIP=c000309a EFL=00000202 [-------] CPL=3 II=0 A20=1 SMM=0 HLT=0
ES =0023 00000000 ffffffff 00cff300
CS =001b 00000000 ffffffff 00cffa00
SS =0023 00000000 ffffffff 00cff300
DS =0023 00000000 ffffffff 00cff300
FS =0023 00000000 ffffffff 00cff300
GS =0023 00000000 ffffffff 00cff300
LDT=0000 00000000 0000ffff 00008200
TR =002b c0000380 00000068 c040e900
GDT=     c000004b 0000002f
IDT=     c000024f 00000117
CR0=e0000011 CR2=000003e4 CR3=00046000 CR4=00000000
CCS=00000044 CCD=00000246 CCO=EFLAGS
FCW=037f FSW=0000 [ST=0] FTW=00 MXCSR=00001f80
FPR0=0000000000000000 0000 FPR1=0000000000000000 0000
FPR2=0000000000000000 0000 FPR3=0000000000000000 0000
FPR4=0000000000000000 0000 FPR5=0000000000000000 0000
FPR6=0000000000000000 0000 FPR7=0000000000000000 0000
XMM00=00000000000000000000000000000000 XMM01=00000000000000000000000000000000
XMM02=00000000000000000000000000000000 XMM03=00000000000000000000000000000000
XMM04=00000000000000000000000000000000 XMM05=00000000000000000000000000000000
XMM06=00000000000000000000000000000000 XMM07=00000000000000000000000000000000
Aborted

The usermode code is: 

   asm volatile("  \
     cli; \
     mov $0x23, %ax; \
     mov %ax, %ds; \
     mov %ax, %es; \
     mov %ax, %fs; \
     mov %ax, %gs; \
                   \
     mov %esp, %eax; \
     pushl $0x23; \
     pushl %eax; \
     pushf; \
     pop %eax; \
     or $0x200, %eax; \
     push %eax; \
     pushl $0x1B; \
     push $1f; \
     iret; \
   1: \
     hlt; \
     ");

If we remove the hlt, then the triple fault report looks like: 

qemu: fatal: triple fault
EAX=00000246 EBX=0000d040 ECX=000000ff EDX=00000004
ESI=ffff7c2b EDI=000882d9 EBP=0008ffec ESP=0008ffcc
EIP=c000339d EFL=00000202 [-------] CPL=3 II=0 A20=1 SMM=0 HLT=0
ES =0023 00000000 ffffffff 00cff300
CS =001b 00000000 ffffffff 00cffa00
SS =0023 00000000 ffffffff 00cff300
DS =0023 00000000 ffffffff 00cff300
FS =0023 00000000 ffffffff 00cff300
GS =0023 00000000 ffffffff 00cff300
LDT=0000 00000000 0000ffff 00008200
TR =002b c0000380 00000069 c0408900
GDT=     c000004b 0000002f
IDT=     c000024f 00000117
CR0=e0000011 CR2=000003e4 CR3=00046000 CR4=00000000
CCS=00000044 CCD=00000246 CCO=EFLAGS
FCW=037f FSW=0000 [ST=0] FTW=00 MXCSR=00001f80
FPR0=0000000000000000 0000 FPR1=0000000000000000 0000
FPR2=0000000000000000 0000 FPR3=0000000000000000 0000
FPR4=0000000000000000 0000 FPR5=0000000000000000 0000
FPR6=0000000000000000 0000 FPR7=0000000000000000 0000
XMM00=00000000000000000000000000000000 XMM01=00000000000000000000000000000000
XMM02=00000000000000000000000000000000 XMM03=00000000000000000000000000000000
XMM04=00000000000000000000000000000000 XMM05=00000000000000000000000000000000
XMM06=00000000000000000000000000000000 XMM07=00000000000000000000000000000000
Aborted

If we hlt just before the iret, we see eip = 0xc000309a.  If we stick a nop in
rather than a hlt, the eip for the triple fault changes to 0xc000339e, which,
disassembling in gdb (after changing the nop to a hlt, so that hopefully 0xc000339e
is still where it would have faulted, assuming hlt and nop are the same size),
we see: 

0xc000339e:     int    $0x22
0xc00033a0:     leave
0xc00033a1:     ret

Hmm.  What if we hlt in kernel.c after calling usermode?  Ah, no, stupid
idea--userland cannot hlt.  If we spin (jmp $) after calling usermode,
everything seems to work fine.  In fact, if we save the stack pointer as what
it was when we initize the tss by doing: 

  u32 espv;
  asm volatile("mov %%esp, %0": "=r"(espv));
  tss_init((tss_entry_t *)tss_start, 0x10, espv);

then we don't get the triple-faulting, and if we don't int 0x22 after
switching to userland, info registers indicates we are in CPL=3 (and this
remains true even after typing stuff on the keyboard).  

Unclear, but the same behaviour is observed on RHW (after a scare with some
RAM registering as unreadable or something: 

First boot says: 

`The amount of system memory has changed (read at 0x4000000 was -------- and
not --------- (or something)'

Switch RAM slots.  

Second boot says: 

`The amount of system memory has changed'

(Unclear if this means it has changed from the decreased value after the
previous boot or just noting that the RAM had changed slots or what.)  

Third boot proceeds as normal.  

Just something to bear in mind.  

But the fact that it works fine here at least shows the ramdisk works properly
on RHW as well (e.g. it doesn't assume zeroed memory unreasonably and
suchlike).  

224602


20090902:235555:Usermode GPF

Aha!  Inserting the lines: 

  print_hex_32(regs.int_no);
  asm("hlt");

at the start of our interrupt handler prints nothing (until we press a key or
whatever) without the int 0x22, but outputs 'D' when we do--a general
protection fault.  The same thing happens when we replace the interrupt call
with 'hlt' or 'cli'.  So perhaps we don't have the privilege to call at least
this interrupt from usermode.  Perhaps we need either to set some flag
somewhere or to use a different interrupt (e.g. 0x80).  

235929


20090903:001200:More on the GPF

Inserting further at the start of the interrupt handler: 
  print_hex_32(regs.eip);

gives the output 0xC00033B2.  Connecting again with gdb, we see: 

(gdb) disassemble 0xc00033b2 0xc00033b6
Dump of assembler code from 0xc00033b2 to 0xc00033b6:
0xc00033b2:     int    $0x22
0xc00033b4:     leave
0xc00033b5:     ret
End of assembler dump.

So it is indeed the interrupt that causes this.  

...

Wow.  I am an idiot.  The IDT has a field for specifying DPL that I left as 0
(for int 0x22) when it should have been 3.  Doink.

We now have usermode.  

023144


20090908:172635:Tasking and Allocator II

Implementing multitasking is the first instance in which we seriously need to
use our allocator, which leads to some further thoughts on this front: 

The structs we are allocating are of different but fixed sizes, so a feature
that seems handy at least for a small kernel's kernel-space allocator such as
this but indeed possibly for many object-based userspace applications as well
is to have the allocator interface allow for individual applications (and,
importantly, individual parts of the kernel) to request `heaps' that allow for
allocation of fixed-size blocks.  E.g., the tasking-manager can have one heap
for allocating 4096-byte blocks for paging structs and another for allocating
sizeof(node_t)-sized blocks for nodes, etc.  

This could allow us to implement a simple sort of state-caching as described
by Bonwick (1994, USENIX Summer, 87-98), if desired as well.  

That having been said, the actual set of procedures involved with multitasking
is rather basic: 

new_task: 
  create new page-table with kernel-mappings already in place
  create page tables for task
  allocate node_t struct and requisite event_t/conn_t structs
  map in specified regions for task and load it there
  fill the node_t struct as required

unload_task:
  dump all structs referenced in the corresponding node_t
  
switch_task:
  switch pagedirs and jump to the entry address of the new task


After our brief break of sleeplessness and worrying about the allocator, we're
off!  

09:005755



20090909:133333:Alligator II (continued)

Firstly, we note what heaps we will use in the kenrel together with
(object-size, slab-size, max objects, constructor, destructor)

page_dir(0x1000, 0x4000, MAX_NODES, fill_with_kernel_PTs, fill_with_kernel_PTs)
page_table(0x1000, 0x10000, 0x300*MAX_NODES, zero, zero)
node_t(sizeof(node_t), 0x1000*10, zero, zero)
stack_t(0x1000, 0x4000, MAX_NODES, zero, zero)
event_t(sizeof(event_t), 0x4000, MAX_EVENTS, zero, zero)
connection_t(sizeof(connection_t), 0x4000, MAX_CONNECTIONS, zero, zero)

Taking our cue from Bonwick, we define the allocator interface simply thus: 

kheap_t *make_heap(object_size, slab_size, max_objects, void *constructor(void *, size_t), void *destructor(void *, size_t))
void dump_heap(kheap_t *heap)
void heap_alloc(kheap_t *heap, u32 objs)
void heap_free(kheap_t, *heap, void *obj)

where behind the allocator we have the functions: 

void expand_heap(kheap_t *heap)
void contract_heap(kheap_t *heap)

170333


20090909:182759:Alligator III--A heap of heaps!

An issue has arisen!  Where do we put the heaps we are allocating things in?
The evident answer is to have a heap for the heap structs.  But how do we make
this heap?  The answer is to kmalloc space for just that one heap (and
free-stack, which may in fact be rather large...) and then call not a `create'
function, but an initialize function on the pre-allocated struct (and such a
function should be made available for most of the data-structure types
anyway).  

231823


20090910:212111:A brief note about non-urgent TODOs

A few things that will need to be cleaned up at some point that we can do
without for the time being: 

-Getting a proper memory map (int 0x15, eax=0xE820) and handling this in the
   physmem manager
-Checking the available video modes and setting the optimal one and passing
   the relevant data on to the video driver.  
-Ensuring that the A20 line was actually enabled (and retrying if not).  
-Not assuming certain memmory is pre-zeroed (unclear as yet when or if this
   happens--will check code more carefully when the time comes).  

This list may expand as I think of things.  

212922


20090922:034805:Alligator; Physmem Mgr within Vmem Mgr

Still stuck on allocator.  There are a few issues--for instance, if we extend
Bonwick's small-object scheme to any heap, but include slab_descriptor_t
pointers in the block structs as well as block_descriptor_t linkage pointers,
we get the albeit not massively unfixable problem of what to do with objects
requiring special alignment constraints, e.g. pagedirs.  So having the block
and slab descriptors in their own separate heaps seems useful (though one
needs to be careful, as it turns out, for if these heaps themselves use
external block/slab descriptor heaps, then allocating a block anywhere causes
an allocation on the block heap, which causes an allocation on the block heap,
etc., explaining why the optimization for small-object caches is not only
space-saving, but is actually necessary).  

However then, given a block, unless we want to just sort out the freelist for
entire free slabs in idle time (in a way that is, additionally, forced to
check the entire freelist and runs in n^2 time in its size) we need to be able
to track down which slab it lives in (in order to adjust a bitmap entry or
update a reference count on alloc/free operations), and in particular, to
track down the slab descriptor.  The correct way to do this is to include the
slab's descriptor (or a pointer thereto) in the slab itself.  We can, after a
struggle, work out the start and end of the slab arithmetically given the
heap's start and slab_size and block_size, but including the descriptor in the
slab itself runs into particular problems when handling alignment-constrained
structures like page-tables--a slab of page tables will have all but its last
page full, with only one byte used in the final page--4095 bytes of RAM wasted
for every such slab allocated.  

The wastage does not appear so much when there are no alignment constraints,
but when dealing with 2K objects, adding an extra dword increases the
slab-size necessary to avoid wastage.  Although, when dealing with objects of
size 2048 - sizeof(dword) we benefit, so perhaps, assuming these are equally
likely, we should not worry about it overly much.  The only concern, then,
happens when we have alignment constraints, and the object size divides (with
small quotient) the page size (which is most significantly true for pagetables
and pagedirs).  Perhaps if we just increase the slab size enough we can suck
it up.  Alternatively, we can use a slab size of i page, but every
4096/sizeof(dword) slabs insert a page of (slab_descriptor_t *)-type
pointers.  Then we can still arithmetically determine the index of any block's
slab and, dividing it by 4096/sizeof(dword) we can determine which of the
pointer-slabs it lives in, 

Actually, we can just have the dword represent the refcount and store no
further metadata for the slabs, and further, we can do this for any heap.  So
the structure of the system is as follows: Every heap will store a value for
the max_used_slab.  Every 1024 slabs, there will be a page of refcounts for
each of the 1024 slabs that follow.  The procedure for allocation then follows
straightforwardly: Use the freelist to find a free block.  Determine its
slab's location, and thus its slab's index in the array, and update the
refcount, and update the freelist as usual.  Then, if a new slab was needed,
check the if the slab's index is greater than the max, and if so, update the
max.  Then, if the max is in turn newly greater than a multiple of 1024,
allocate a further page of refcounts.  

Indeed, we can use the same sort of thing for block descriptors.  So, for
example, the layout in RAM would look something like: 

             SIZES          ||    RAM    || SLABS  |BCHUNKS |SCHUNKS |
============================||===========||========|========|========|
 heap->slab_metadata_size   ||slab       ||        |        | SLAB   | 
                            ||descriptors||        |        | CHUNK  |
============================||===========||        |========|(SCHUNK)|
 heap->block_metadata_size  ||block      ||        | BLOCK  |        |
                            ||descriptors||        | CHUNK  |        |
============================||===========||========|(BCHUNK)|        |
 heap->block_size           ||block      ||  SLAB  |        |        |
============================||===========||        |        |        |
 heap->block_size           ||block      ||        |        |        |
============================||===========||        |        |        |
                            ||...        ||        |        |        |
============================||===========||        |        |        |
 heap->block_size           ||block      ||        |        |        |
============================||===========||        |        |        |
                            ||wastage    ||        |        |        |
============================||===========||========|        |        |
                            ||...        ||  ....  |        |        |
                            ||...        ||(SLABS) |        |        |
============================||===========||========|        |        |
 heap->block_size           ||block      ||  SLAB  |        |        |
============================||===========||        |        |        |
 heap->block_size           ||block      ||        |        |        |
============================||===========||        |        |        |
                            ||...        ||        |        |        |
============================||===========||        |        |        |
 heap->block_size           ||block      ||        |        |        |
============================||===========||        |        |        |
                            ||wastage    ||        |        |        |
============================||===========||========|========|        |
 heap->block_metadata_size  ||block      ||        | BCHUNK |        |
                            ||descriptors||        |        |        |
============================||===========||========|        |        |
 heap->block_size           ||block      ||  SLAB  |        |        |
============================||===========||        |        |        |
                            ||...        ||        |        |        |
============================||===========||        |        |        |
 heap->block_size           ||block      ||        |        |        |
============================||===========||        |        |        |
                            ||wastage    ||        |        |        |
============================||===========||========|        |        |
                            ||...        ||(SLABS) |        |        |
                            ||...        ||        |========|        |
                            ||...        ||        |BCHUNKS |        |
============================||===========||========|========|        |
 heap->block_metadata_size  ||block      ||        | BCHUNK |        |
                            ||descriptors||        |        |        |
============================||===========||========|        |        |
 heap->block_size           ||block      ||  SLAB  |        |        |
============================||===========||        |        |        |
                            ||...        ||        |        |        |
============================||===========||        |        |        |
 heap->block_size           ||block      ||        |        |        |
============================||===========||        |        |        |
                            ||wastage    ||        |        |        |
============================||===========||========|========|========|
 heap->slab_metadata_size   ||slab       ||        |        | SCHUNK |
                            ||descriptors||        |        |        |
============================||===========||        |        |        |
                            ||...........||        |        |        |
                              ...........   

In code (roughly): 


TYPES/DEFINITIONS: 

typedef slab_descriptor{
   u32 refcount;
}slab_descriptor_t;

typedef block_descriptor{
   block_descriptor_t *prev;
   block_descriptor_t *next;
} block_descriptor_t;

typedef struct kheap{
  u32 flags; //0:(1=Small) 1-31:RESERVED
  u32 block_size;
  u32 slab_size;
  u32 max_size;
  u32 alignment;
  void (*constructor)(void *);
  void (*destructor)(void *);
  void *start;
  void *end;
  block_descriptor_t *first_free;
  block_descriptor_t *last_free;
  u32 bchunk_size;
  u32 schunk_size;
  u32 slabs_per_bchunk;
  u32 effective_block_size;
  u32 bchunks_per_schunk;
  u32 bchunk_metadata_size;
  u32 schunk_metadata_size;
} kheap_t;

#define PAGE_SIZE 4096
#define SLABS_PER_SCHUNK PAGE_SIZE/sizeof(slab_descriptor_t)
#define BLOCKS_PER_BCHUNK PAGE_SIZE/sizeof(block_descriptor_t)


CREATE: 

kheap_t *kheap_init(kheap_t *heap, u32 b_size, u32 s_size, u32 m_size, u32
init_slabs, u32 align, void *constr(), void *destr(), u32 safe_offest, void
*location){
  if(b_size < PAGE_SIZE/8){
    heap->flags != 1;
    heap->alloc = kheap_small_alloc(u32);
    b_size += sizeof(block_descriptor_t *);
  }
  else{
    heap->alloc = kheap_alloc(u32);
  }

  heap->block_size = b_size;
  heap->slab_size = s_size;
  heap->max_size = m_size;
  heap->alignment = align;
  heap->constructor = constr;
  heap->destructor = destr;
  heap->start = location;
  heap->end = location;
  heap->first_free = heap->get_block(0);
  heap->last_free = heap->get_block(init_slabs*s_size/block_size);

  heap->slabs_per_bchunk = BLOCKS_PER_BCHUNK / ((heap->slab_size)/(heap->block_size));
  heap->bchunks_per_schunk = SLABS_PER_SCHUNK / heap->slabs_per_bchunk;
  heap->bchunk_metadata_size = align_by(BLOCKS_PER_BCHUNK*sizeof(block_descriptor_t), PAGE_SIZE);
  heap->schunk_metadata_size = align_by(SLABS_PER_SCHUNK*sizeof(slab_descriptor_t), PAGE_SIZE);
  heap->effective_block_size = align_by(heap->block_size, heap->align);
  heap->bchunk_size = heap->slabs_per_bchunk*(heap->slab_size) + heap->bchunk_metadata_size;
  heap->schunk_size = SLABS_PER_SCHUNK*(heap->slab_size) + (heap->bchunk_metadata_size)*(heap->bchunks_per_schunk) + (heap->schunk_metadata_size);

  kheap_expand(heap, init_slabs);
  return heap;
}



ALLOC: 

//Expand if needed
if(heap->first_free == NULL) if(expand(heap) != 0) return NULL;

//Update linkage
block_descriptor_t *new_block = heap->first_free;
heap->first_free = heap->first_free->next;
heap->first_free->prev = NULL;

//Update refcount
get_slab_descriptor(new_block)->refcount++;

//Return: 
return get_block_start(new_block);


FREE: 

//Update linkage
block_descriptor_t *to_free = get_block_descriptor(block_start);
to_free->next = NULL;
to_free->prev = heap->last_free;
heap->last_free = to_free;

//Update refcount
(get_slab_descriptor(to_free))->refcount--;

//Reclaim if wanted
//if((get_slab_descriptor(to_free))->refcount == 0)
   contract(to_free);

return;


EXPAND: 

void *new_end = heap->end + heap->slab_size;

//If expanding would put us over a schunk boundary, add another page of slab descriptors: 
if((new_end - heap->start)/(heap->schunk_size) > (heap->end - heap->start)/(heap->schunk_size)){
   new_end += heap->schunk_metadata_size + heap->bchunk_metadata_size;
}
else if((new_end - get_bchunks_start(new_end - heap->block_size))/(heap->bchunk_size) > (heap->end - get_bchunks_start(heap->end - heap->block_size))/(heap->bchunk_size)){
   new_end += heap->bchunk_metadata_size;
}
alloc_pages_for(heap->end, new_end, 1, 1);
heap->end = new_end;

return;

CONTRACT: 

void *i;
u32 j;

for(i = heap->start; i < heap->end; i++) 
{
   for(j = 0; j < SLABS_PER_SCHUNK; j++)
   {
      slab_descriptor_t *slab_desc = (slab_descriptor_t *)i;
      if(slab_desc->refcount == 0){
         free_pages_through(get_slab_start(slab_desc), heap->slab_size);
	 slab_desc->refcount == -1;
      }
      i += sizeof(slab_descriptor_t);
   }
   i += heap->schunk_size - heap->schunk_metadata_size;
}

AUXILIARY FUNCTIONS: 

block_descriptor_t *get_block_descriptor(void *block_start){
   u32 info_start = (u32)(block_start), schunk_index, schunk_start, bchunks_start, bchunk_index, bchunk_start, blocks_start;
   get_location_info(heap, info_start, &schunk_index, &schunk_start, &bchunks_start, &bchunk_index, &bchunk_start, &blocks_start);

   u32 block_index = (info_start - blocks_start)/(heap->block_size);
   
   return ((block_descriptor_t *)(bchunk_start))[block_index];
}

slab_descriptor_t *get_slab_descriptor(block_descriptor_t *block_desc){
   u32 info_start = (u32)(block_desc), schunk_index, schunk_start, bchunks_start, bchunk_index, bchunk_start, blocks_start;
   get_location_info(heap, info_start, &schunk_index, &schunk_start, &bchunks_start, &bchunk_index, &bchunk_start, &blocks_start);

   u32 block_index = (info_start - bchunk_start)/sizeof(block_descriptor_t);
   u32 block_start = block_index + blocks_start * (heap->block_size);

   u32 slab_index_within_bchunk = (block_start - blocks_start)/(heap->slab_size)
   u32 slab_index_within_schunk = bchunk_index * slabs_per_bchunk + slab_index_within_bchunk;

   return ((slab_descriptor_t *)(schunk_start))[slab_index_within_schunk];
}

void *get_slab_start(slab_descriptor_t *slab_desc){
   u32 info_start = (u32)(slab_desc);
   u32 bchunks_start = get_bchunks_start(heap, info_start);
   u32 schunk_start = get_schunk_start(heap, info_start);
   u32 slab_index = ((info_start - schunk_start) / sizeof(slab_descriptor_t));
   u32 bchunk_index = slab_index / (heap->slabs_per_bchunk);
   u32 slab_index_within_bchunk = slab_index % (heap->slabs_per_bchunk);
   return (void *)(bchunks_start + (heap->bchunk_size)*bchunk_index + heap->bchunk_metadata_size + (heap->slab_size)*slab_index_within_bchunk);
}

void *get_block_start(block_descriptor_t *block_desc){
   u32 info_start = (u32)(block_desc), schunk_index, schunk_start, bchunks_start, bchunk_index, bchunk_start, blocks_start;
   get_location_info(heap, info_start, &schunk_index, &schunk_start, &bchunks_start, &bchunk_index, &bchunk_start, &blocks_start);

   u32 block_index = (info_start - bchunk_start)/sizeof(block_descriptor_t);

   return (void*)(blocks_start + block_index*(heap->block_size));
}

inline u32 get_schunk_index(kheap_t *heap, u32 info_start){
   return (info_start - heap->start)/(heap->schunk_size);
}
inline u32 get_schunk_start(kheap_t *heap, u32 info_start){
   return get_schunk_index(heap, info_start) * heap->schunk_size + heap->start;
}
inline u32 get_bchunks_start(kheap_t *heap, u32 info_start){ 
   return get_schunk_start(heap, info_start) + heap->schunk_metadata_size; 
}
inline u32 get_bchunk_index(kheap_t *heap, u32 info_start){
   return (info_start - get_bchunks_start(heap, info_start))/(heap->bchunk_size);
}
inline u32 get_bchunk_start(kheap_t *heap, u32 info_start){
   return get_bchunk_index(heap, info_start) * (heap->bchunk_size) + get_bchunks_start;
}
inline u32 get_blocks_start(kheap_t *heap, u32 info_start){
   return bchunk_start + heap->bchunk_metadata_size;
}

void get_location_info(kheap_t *heap, u32 info_start, u32 *schunk_index, u32 *schunk_start, u32 *bchunks_start, u32 *bchunk_index, u32 *bchunk_start, u32 *blocks_start){
   *schunk_index = (info_start - heap->start)/heap->schunk_size;
   *schunk_start = *schunk_index * heap->schunk_size + heap->start;

   *bchunks_start = *schunk_start + align_by(SLABS_PER_SCHUNK * sizeof(slab_descriptor_t), PAGE_SIZE);
   *bchunk_index = (info_start - *bchunks_start)/(heap->bchunk_size);
   *bchunk_start = *bchunk_index * (heap->bchunk_size) + *bchunks_start;

   *blocks_start = *bchunk_start + align_by(BLOCKS_PER_BCHUNK*sizeof(block_descriptor_t), PAGE_SIZE);
   return;
}

u32 align_by(u32 size, u32 block_size){ return size + (size % block_size != 0 ? block_size : 0) - (size % block_size); }

//================================

Of course, there are better ways to deal with some of these things.  It is
easier to reclaim stuff if we make slab_desctiptor_t structs also contain a
pointer to the first free block in the slab, and then let the freelist be
managed slab-wise, while also maintaining a linked-list of slabs in the
slab_descriptor information, and while all these things should be implemented
in the final version, the above is mainly for reference to the arithmetic
`compute the location of this information given that information' things,
which are tricky.  



A separate issue arises when we want to subsume the physmem manager into the
allocator.  After all, expanding a heap of pagetables may at some point
(e.g. after allocating 4096 page tables) itself require the allocation of
another pagetable.  

So suppose we implement the physmem allocator naively on top of the vmem
allocator and subsequently find ourselves in the unfortunate situation of
having our pagedir with a single pagetable listed as `present' which in turn
has all of its pages listed as `present' and in fact in use, and, with all
this being true, want to expand some heap.  This will require allocating
another page, which will require expanding the heap of pagetables, which, due
to the situation, will cause another call to allocate a page, which, as it is
still impossible without allocating another pagetable, will trigger another
call to do so, and the stack explodes and we die.  

The obvious fix is to pre-allocate all the tables that the table and directory
heaps may ever need.  Indeed, pre-allocating all tables for virtual memory
above 0xC0000000 (i.e. all kernel tables) seems like a good idea anyways, as
we then wouldn't have to update a bunch of processes pagedirs everytime some
metadata was allocated for connections or events or whatever in the kernel.  

Then the rest of the physmem should map relatively straightforwardly on top of
our vmem manager, but this is a matter for later.  

28:024846



20090928:131338:Tasking

What should our tasking API look like?  Pretty clearly we want a way of
loading and of dumping nodes, and then of switching to a given node, but
surely these things are easy?  

typedef struct node
{
  u32 UID;
  u32 esp;
  u32 kesp;
  u32 ebp;
  u32 eip;
  u32 pagedir_physical;
  pagedir_t *pagedir;
  node_t *prev;
  node_t *next;
} node_t;

u32 pid = 0;
kheap_t node_heap;
node_t *last_node;
node_t *first_node;
node_t *current_node;
u32 test;

void tasking_init(){
   node_heap = heap_init(heap_create(), ...)
}

node_t *make_node(){
   node_t *node = (node_t *)(heap_alloc(node_heap));
   node->UID = ++pid;
   node->esp = (u32)(heap_alloc(stack_heap));
   node->kesp = (u32)(heap_alloc(stack_heap));
   node->ebp = node->esp;
   u32 test = 0;
   node->eip = 0;//OR: node->eip = get_eip(&test);
   //if(test == 1){
      test = 0;
      node->pagedir = pagedir_new(&(node->pagedir_physical), 1, 1);
      node->next = first_node;
      first_node = node;
      return node;
   //}
   //else return 0;
}

void dump_node(node_t *node){
   if(node->next != NULL) node->next->prev = node->prev;
   else last_node = node->prev;
   if(node->prev != NULL) node->prev->next = node->next;
   else first_node = node->next;
   heap_free(stack_heap, node->esp);
   heap_free(stack_heap, node->kesp);
   pagedir_dump(node->pagedir);
   heap_free(node_heap, node);
}

void switch_to_node(node_t *node){
   u32 esp, ebp, eip = get_eip(&test), cr3;

   asm volatile("mov %%esp, %0" : "=r"(esp));
   asm volatile("mov %%ebp, %0" : "=r"(ebp)); 
   current_node->esp = esp;
   current_node->ebp = ebp;
   current_node->eip = eip;
   
   eip = node->eip;
   esp = node->esp;
   ebp = node->ebp;
   cr3 = node->pagedir_physical;

   asm volatile("          \
      cli;                 \
      mov %0, %%ecx;       \
      mov %1, %%esp;       \
      mov %2, %%ebp;       \
      mov %3, %%cr3;       \
      sti;                 \
      jmp *%%ecx           "
      : : "r"(eip), "r"(esp), "r"(ebp), "r"(cr3));
}

u32 get_eip(u32 *test_value){
   *test_value = 1;
   return asm_get_eip();
}


Or something like that.  Worries include what happens when we switch to node
and store the value of eip in the struct and then jump to it we need to know
whether we just returned from get_eip() or whether we just jumped there from
the switch_to_node function.  Things like this, but this seems like a start.  

185930


20091209:163652:BACK AGAIN!

HA!  Ha ha.  Ha...  Term is over, and time to get this thing moving again,
aye?  Um.  But where were we?  

Our goals from before went something like this: 

-Page-table remapping
-Kernel struct allocator
-Ramdisk loading
-Userland/Syscalls
-Multitasking
-IPC

Where the first four were more or less done by the end of the previous break,
and the final two were given (in some sense) by the skeleton code above.
There remain worries about the allocator, however, which is somewhat untested,
so the best course of action seems to be to clean up the first four and get
them working together nicely, and then implement tasking/IPC on top (as this
should be somewhat easy as long as the allocator works--just allocate and fill
out the relevant structs as appropriate).

10:002325


20091210:173530:Allocator Remix

void *alloc(u32 size){ heap_end += size; return (void *)(heap_end - size); }
void free(void *data){ return; }

No, sorry--just kidding.  Revising the allocator and realizing that the
conversion data address -> descriptor address and back is nasty, (albeit O(1)),
and therefore considering whether we can save on some of this at least by
storing more information.  For instance, we can convert backwards more easily
by storing physical block address in the descriptor, and then the only problem
is going the other way, but at least this is possible.  

12:021640

20091212:021655:Allocator Things

So perhaps we now have a complete picture (if not implementation) of the final
allocator: 

The physical layout is essentially as pictured somewhere far above, which we
reproduce (To scale! Or something!) in small version here: 

|Slab descriptors                           | SCHUNK  |
|Block descriptors   	       | BCHUNK	    |	      |
|Blocks...          | Slab     |	    |	      |
|Waste              |	       | 	    |	      |
|...                           |	    |	      |
|Blocks...          | Slab     |	    |	      |
|Waste              |	       |	    |	      |
|					    |	      |
|Block descriptors             | BCHUNK	    |	      |
|Blocks...          | Slab     |	    |	      |
|Waste              |	       | 	    |	      |
|...                           |	    |	      |
|Blocks...          | Slab     |	    |	      |
|Waste              |	       |	    |	      |
|...                	       |	    |	      |
|...                	                    |	      |
|					    |	      |
|Block descriptors  	       | BCHUNK	    |	      |
|Blocks...          | Slab     |	    |	      |
|Waste              |	       |	    |	      |
|...                           |	    |	      |
|Blocks...          | Slab     |	    |	      |
|Waste              |	       |	    |	      |
|                   	      		   	      |
|Slab descriptors   	      		    | SCHUNK  |
|					    |	      |
|Block descriptors  	       | BCHUNK	    |	      |
|Blocks...          | Slab     |	    |	      |
|Waste              |	       |	    |	      |
|...                           |	    |	      |
|Blocks...          | Slab     |	    |	      |
|Waste              |	       |	    |	      |
|.....................................................|
|.....................................................|
|.....................................................|

But this is only half the story, how we access this and what data we store for
this purpose is the rest.  To the end of elucidating this, we go through the
structs in their current state: 

SLAB DESCRIPTOR: 

typedef struct slab_descriptor{
  void *start;
  u32 refcount;
  slab_descriptor_t *next;
  slab_descriptor_t *prev;
} slab_descriptor_t;

Slab descriptors go at the start of each SCHUNK.  Each descriptor has a
pointer to the start of the physical slab itself (which, as mentioned
somewhere abouve, could be calculated, but this is part of the time/space
tradeoff).  It stores the refcount for that slab--i.e. how many blocks within
that slab are in use at the moment.  

The slabs of refcount zero may be freed at some point via contraction, so
we'll want to keep track of them--in this case, by placing them on a
doubly-linked list--the slab freelist.  This will be updated at each
alloc/free and manipulated during expansion/contraction.  

BLOCK DESCRIPTOR: 

typedef struct block_descriptor{
  void *start;
  slab_descriptor_t *slab_desc;
  void *prev;
  void *next;
} block_descriptor_t;

Like a slab descriptor, each block descriptor points to its physical start,
and also contains a pointer to the slab descriptor corresponding to the slab
that its block is in.  Also like the slab descriptors, the free blocks are
placed on a freelist, this time not for the purpose of contracting, but for
finding a free block to satisfy any allocation requests that may come around.
Note that we may optimize by placing blocks within a contracted slab at the
end of the block freelist, so that these will not be used for allocations
unless absolutely necessary.  This will make contractions take longer, but
perhaps, as this is expected to be a rare operation anyways, this may be
beneficial.  

BLOCK INFO: 

typedef struct block_info{
  block_descriptor_t *block_desc;
  slab_descriptor_t *slab_desc;
  void *schunk_start;
  void *bchunk_start;
} block_info_t;

As mentioned several times, we want to be able to go from block location
information to the metadata without having some pointer actually stored within
the block (which could step on constructed state or make alignment suboptimal
if not).  We do this by having a function that can fill out a struct of
pointers to all the relevant metadata we could ever ask for, namely, the
descriptos for the corresponding block and slab, as well as the start of the
schunk and the bchunk in which this block and slab live.  

The method of doing this is simple, and is as follows: 

void get_block_info(kheap_t *heap, void *block_start, block_info_t *info){
  u32 u32_block_start = (u32)(block_start);
  u32 schunk_index = (u32_block_start - (u32)(heap->start))/(heap->schunk_size);
  info->schunk_start = (void *)(schunk_index * (heap->schunk_size) + (heap->start));

  u32 bchunks_start = (u32)(info->schunk_start) + heap->schunk_metadata_size;
  u32 bchunk_index = (u32_block_start - bchunks_start)/(heap->bchunk_size);
  info->bchunk_start = (void *)(bchunk_index * (heap->bchunk_size) + bchunks_start);

  u32 blocks_start = (u32)(info->bchunk_start) + heap->bchunk_metadata_size;
  u32 block_index = (u32_block_start - blocks_start)/(heap->block_size);
  info->block_desc = (block_descriptor_t *)(info->bchunk_start + block_index*sizeof(block_descriptor_t));

  u32 slab_index = bchunk_index * (heap->slabs_per_bchunk) + (heap->slab_size) * ((u32_block_start - blocks_start)/(heap->slab_size));
  info->slab_desc = (slab_descriptor_t *)(info->schunk_start + sizeof(slab_descriptor_t)*slab_index);

  return;
}

HEAP: 

typedef struct kheap{
  u32 block_size;
  u32 slab_size;
  u32 blocks_per_slab;
  u32 max_size;
  u32 alignment;
  void *(*constructor)(void *);
  void *(*destructor)(void *);
  void *start;
  void *end;
  block_descriptor_t *first_free;
  block_descriptor_t *last_free;
  slab_descriptor_t *first_free_slab;
  slab_descriptor_t *last_free_slab;
  u32 slabs_per_bchunk;
  u32 bchunks_per_schunk;
  u32 bchunk_metadata_size;
  u32 schunk_metadata_size;
  u32 effective_block_size;
  u32 bchunk_size;
  u32 schunk_size;
} kheap_t;

All the information that we need to keep track of all the above (e.g. manage
freelists and so on) is here, as well as some convenient numbers that we could
calculate on the fly, but that are more convenient stored somewhere, like
effective_block_size or slabs_per_bchunk (which really gives rise to very
little fruther overhead, comparatively, as there are typically not many heaps).



The procedures we can run on a heap are: 

CREATE: 

Fill out the heap struct, precomputing all fixed values.  

ALLOCATE: 

Take the first free block off the freelist, updating linkage
Update the refcount of the corresponding slab, and, if needed, take that slab
off the slab freelist, and then return the start of the block.  

FREE: 

Find the descriptor of the given block using get_block_info and add it to the
freelist, updating linkage.  Then update the corresponding slab's refcount and
add it (updating linkage) to the slab freelist if needed.  

EXPAND: 

Add a new slab to the heap.  This will extend the end of the heap by
heap->slab_size unless we are at a BCHUNK or an SCHUNK boundary.  In the case
of being at an SCHUNK boundary, we will also need to allocate space for a new
sked of metadata for both a new SCHUNK and a new BCHUNK, whereas if we are
only at a BCHUNK boundary, we will need to allocate space for a new blob of
block metadata only.

Then, having a new slab, fill out its start descriptor, set its refcount to
zero, and add it to the slab freelist, updating linkage.  

This slab has lots of new free blocks, each of which needs its start pointer
fixed, slab descriptor pointer pointing back to the descriptor we were dealing
with above, and to be added to the block freelist, updating linkages
appropriately.  

CONTRACT: 

Free a slab in physical memory.  This is the tricky bit: If we have freed all
the slabs in a BCHUNK, it would be nice to be able to free the metadata as
well and actually lose that part of the heap altogether (though it is worth
noting that even without this, we are already doing better than the standard
malloc, which doesn't contract at all).  To do this, it may be possible to
maintain block freelists on a BCHUNK basis, (and slab freelists on an SCHUNK
basis), but this makes the arithmetic for get_block_info again a bit more
complicated, so we'll put off implementing this particular idea until later.
If we did this, however, we would be able to free entire BCHUNKS and, if it
came to that, entire SCHUNKS.  

That aside, this is a rather simple operation, looking at the first slab on
the slab freelist and giving the corresponding pages back to the physmem
allocator, keeping all the metadata so that if there is an allocation attempt
that tries to get a freed page, the page-fault handler can bring the slab back
into play with nothing lost, transparently (save for a small delay, as
usual).  

025659


20091212:115353:Function Pointers Note

Because the allocator has information about the construction and destruction
of its member objects, it has to have function pointers to the constructor and
destructor for those objects, which involves function pointers.  

Just to note--mostly for my future self, as it is something unlikely to be
used frequently, so easy to forget: 

In the kheap_t struct, we have: 

void *(*constructor)(void *);

which signifies a function taking one void pointer argument, returning a void
pointer, and that it is a pointer to such a function (which is why the second
star is there).

Then, the initialization function which will take this function as an input
has signature: 


kheap_t *kheap_init(kheap_t *heap, u32 b_size, u32 s_size, u32 m_size, u32
init_slabs, u32 align, void * (*constr)(void *), void *(*destr)(void *), void
*location){

Same reasoning behind this.  And now, when we wish to call this function, we
define a function of appropriate signature thus: 

void *zero(void *a){ *((u32 *)(a)) = 0; }

and then pass its address as the pointer to the function, thus: 

kheap_init(node_heap, sizeof(node_t), align_by(sizeof(node_t), 4096),
NODE_HEAP_SIZE, 1, 0, &zero, &zero, (void *)NODE_HEAP_START);

165922


20091212:160212:Testing

So the code for paging, allocator, ramdisk, and syscalls is all finished, and
we spend the next few days testing and polishing before moving on to the real
meat of the matter--IPC.  

Init looks like: 

kheap_t *node_heap;

#define NODE_HEAP_START 0xC1000000
#define NODE_HEAP_SIZE 0xE000000

void *zero(void *a){ *((u32 *)(a)) = 0; }

void ks_heap_init(){
  kheap_init(node_heap, sizeof(node_t), align_by(sizeof(node_t), 4096), NODE_HEAP_SIZE, 1, 0, &zero, &zero, (void *)NODE_HEAP_START);
}

void init(u32 vidstart, u32 rdstart, u32 tss_start)
{
  monitor_init((pixel_t *)vidstart);
  prints("INITIALIZING PAGING!          ");
  paging_init();
  prints("DONE!\nINITIZING KERNEL ALLOCATOR!   ");
  ks_heap_init();
  prints("DONE!\nPREPARING RAMDISK!            ");
  rd_init((void *)rdstart);
  prints("DONE!\nENTERING USERLAND!            ");
  u32 espv;
  asm volatile("mov %%esp, %0": "=r"(espv));
  tss_init((tss_entry_t *)tss_start, 0x10, espv);
  //tasking_init(tss_start);
  prints("DONE!\nCONFIGURING PCI DEVICES!      ");
  //pci_init();
  prints("DONE!\nBOOTING COMPLETE!");
}

and issues the output: 

INITIALIZING PAGING!          DONE!
INITIZING KERNEL ALLOCATOR!   PAGE FAULT: at 0x4 with error code 10

Hmph...

Right--we need to allocate the node_heap before filling it out and we need to
check for block_size == 0 in align_by to avoid divide-by-zero errors.  

Now when we call expand, we get 

PAGE FAULT: at 0xFFFFFFFC with error code

Hmph...

This seems to be a problem with the page allocation bit...

Erk.  

setm((u32 *)(frames_map->bitmap->bits), num_frames, 0);

-> 

setm((u32 *)(frames_map->bitmap->bits), num_frames/32, 0);


But further, this is already done in bitmap.c.  WHAT ON EARTH?!  

Anyways.  Sorted.  

Now we get 

PAGE FAULT: at 0xE100000C with error code

Now what?

Erk.  Stack difficulties--Our stack push function was: 

int stack_push(stack_t *s, u32 x){
  if(s->top - s->base >= s->max){
    return -1;
  }
  *(++(s->top)) = x;
  return 0;
}

Whereas, for one, we have the top being below where it is supposed to be at
all times, so this is guaranteed to mess up at the start, given that we have
stack->top = stack_base - 1 then.  

We fix: 

u32 stack_push(stack_t *s, u32 x){
  if(s->top - s->base >= s->max && s->top - s->base != -1){
    return -1;
  }
  s->top += 1;
  *(s->top) = x;
  return 0;
}

Now the stack looks somewhat correct (will check more precisely later), but
we get 

PAGE FAULT: at 0x0 with error code 

HARUMPH!  

Actually, it looks like we broke the paging initialization now...

ARGH! 

Evidently it happens on the call to switch_pagedir...

One thing that is evident is that earlier, as the stack always starts out
with s->top = s->base - 1, calls to stack_push do nothing.  Now that they do
in fact do something, we see problems, which we can get rid of by eliminating
calls to stack push in imap_create (well, not get rid of so much as cover
over).  

Interestingly, if we do the first 26760 stack pushes thus: 

imap_t *imap_create(u32 size)
{
  imap_t *imap = (imap_t *)kmalloc(sizeof(imap_t));
  imap->bitmap = bitmap_create(size*8);
  imap->stack = stack_create(size);
  u32 i;
  for(i = 0; i < 26760; i++){
    stack_push(imap->stack, size - 1 - i);
  }
  return imap;
}

we get the result 

PAGE FAULT: at 0x8 with error code 10

and the prints calls that execute indicate that alloc_pages_for completes
successfully (!?).  And we get this same result for when we do any number of
stack pushes between 1 and 26760.  But when we do more than 26760, we get a
failure on switch_pagedir.  (Also interesting, 26760 = 0x6888.  Hmm...).  On
the other hand, if we do no stack pushes, we get 

PAGE FAULT: at 0xD0000008 with error code 10

So perhaps the stack is stepping on something or is otherwise broken, and has been all
along.  

Ah.  For one thing, to allocate space for the stack we need to grab 4*(s->max)
bytes, rather than s->max bytes, considering that the stack takes u32s as its
elements.  (Same holds for bitmap_t, and same adjustments have been made.)  

This removes the 0x6888 problem (which seems to have been occuring because the
stack started at 0xC100401C in vmem, i.e. 0x3401C in physmem, and
0x3401C+0x6888*4 = 0x4E23C, which means that the stack would have been
stepping on the page mapping for memory starting at 0.  

Having adjusted this as appropriate, we now get the same behaviour for values
greater than 0x6888 as for those less than 0x6888, but this is in turn the
same behaviour as above, i.e. it is different when we allocate anything on the
stack compared with when we don't.  This is still mysterious.  

Perhaps this stack steps on the actual (esp/ebp-defined) stack?  Where did
that go anyways?  Apparently it lives between 0x80000 and 0x90000, if we
believe the most recent reference found above, and indeed, stage2.asm and
paging.c corroborate this.  

On the other hand, by all appearances, after the previous adjustments, our
page directory now resides at (dun dun dun) 0x82000, and the page tables creep
up to 0x8E000.  This is, if not a disaster right now, certainly a recipe for
future catastrophe.  However, it is questionable whether this is the cause of
our current crisis, considering the stack doesn't appear to stretch down below
0x8FCE2, and the PD/PT data doesn't encroach beyond 0x8E000.  So it seems that
we should have been safe?

Nonetheless, we shall shortly have to do some physical memory reorganization.
(The simplest way to do this, I suspect, is to define a `kernel data' area
that lives beyond the stack, in which all kernel pagedirs and associated
stacks and bitmaps and other such things shall reside, and which we can expand
with impunity.)

However, until then, we note that the prints's seem to tell us that the
problem occurs when we call 

get_block_info(heap, &info, new_slab_start);

and more precisely, on the line 

info->schunk_start = (void *)(schunk_index * (heap->schunk_size) + (heap->start));

Actually.  Wait.  Blah.  

If we put the stack pushes back (all of them), the only problem we get is
the page fault at 0x8, where we do appear (as indicated by the prints lines)
to make it out of the get_block_info call.  

But in fact, this makes sense because we are doing things like: 

info.slab_desc->start = new_slab_start;

where info.slab_desc has just been computed as the pointer to the slab
descriptor RELATIVE TO THE START OF THE HEAP!  So we just need to add the
start offset of the heap to everything and then we should have some kind of
success.  

AAAAaaaaaaaand, compare: 

get_block_info(heap, &info, new_slab_start);

void get_block_info(kheap_t *heap, void *block_start, block_info_t *info)

BLAH!

Just as a warning--the heap appears not to be properly mapped, possibly, as,
according to the QEMU monitor, 

0x82D00: 0x0008C007 0x00000000 ...
...
0x8C000: 0x00000007 0x00000000 ...

So somehow, the physical allocator has assigned the block of memory starting
at 0 to the heap.  We test more fully later, but it appears for now that
alloc_pages_for is working entirely correctly.  

Now, when we output the block info, we see: 

schunk_start: D0000000
bchunk_start: D0000000
block_desc: 62494B60
slab_desc: CFFF0010

What.  

Followed by 

PAGE FAULT: at 0xCFFF0010 with error code 10

No kidding.  

So our arithmetic is wrong somewhere...

Ah.  No it's not, my brain is just wrong somewhere.  We allocate the metadata
blocks when we get to the end of a chunk, rather than at the start, so the
start of the new slab will always be the end of the current heap.  Now that's
fixed, and we get 

PAGE FAULT: at 0x8 with error code 10

...

This grows slightly tiresome--in the future, all code should be tested after
every new line is written to ensure proper behaviour, rather than this `write
a bunch and spend five days debugging' garbage.  

Oh yeah--last_free_slab could be NULL.  

AND NOW IT WORKS!  

At least, no page faults, and the debug print looks normal.  Will check more
fully later, but for now I think we've earned a WHEW!

Not fully out of the woods though, as we shall have to do some physical memory
reorganization in the near future, so it's back to dangerland.  

18:131808

20091219:143434:What to do

What to do indeed.  We need to finish IPC and multitasking, and then cobble
together some executable loader, and this could easily constitute a complete
version 0.

However, to do this we need to be entirely certain that the physmem and vmem
allocators are working perfectly.  So the first thing to do is to test first
the physmem allocator with some allocs and frees, and then the vmem
allocator.  

So our goals for this round are: 

Reorganize RAM
Test Allocators

First in the reorganizing RAM, we need a better isolated esp/ebp stack.  

The current stage2 PD/PT setup has the mappings: 

0x00000000-0x00400000 -> 0x00000000-0x00400000 (So the current code survives)
0x00010000-0x00410000 -> 0xC0000000-0xC0400000 (kernel)
0x00030000-0x00430000 -> 0xC1000000-0xC1400000 (kernel data)
[t_vidmem]-end vidmem -> [t_vidmem]-end vidmem (vidmem)

This is of course, a bit excessive, but it is just for starters, and we throw
away these mappings rather quickly in favour of those given in paging.c by the
lines: 

  #define K_BASE_PHYS 0x10000
  #define K_DATA_PHYS 0x30000
  #define K_DATA_SIZE 0x400000
  #define K_RAMDISK_PHYS 0x20000
  #define K_RAMDISK_SIZE 0x1000
  #define K_STACK_PHYS 0x80000
  #define K_STACK_SIZE 0x10000
  #define K_SIZE 0x400000
...
  paging_idmap((void *)(videoram), height*width*3, 1, 0);
  paging_mapto((void *)K_BASE_PHYS, K_SIZE, (void *)0xC0000000, 1, 0);
  paging_mapto((void *)K_DATA_PHYS, K_DATA_SIZE, (void *)0xC1000000, 1, 0);
  paging_idmap((void *)K_RAMDISK_PHYS, K_RAMDISK_SIZE, 1, 0);
  paging_idmap((void *)K_STACK_PHYS, K_STACK_SIZE, 1, 0);

which define the translation-mapping 

videomem is idmapped                           (vidmem)
0x00010000-0x00410000 -> 0xC0000000-0xC0400000 (kernel proper)
0x00030000-0x04300000 -> 0xC1000000-0xC1400000 (kernel data)
0x00020000-0x00021000 -> 0x00020000-0x00021000 (ramdisk)
0x00080000-0x00090000 -> 0x00080000-0x00090000 (stack)

However this is less than preferable, perhaps, as we see that way more than
needed is mapped for the kernel itself, and that both the kernel and the
kernel's data overlap severely with the stack, with the potential to squish it
if they actually use this part of their territory.  So we decide to reorganize
a bit more prudently, perhaps something like the following (noting that the
current kernel is fewer than 0xC200 bytes): 

vidmem is idmapped                             (vidmem)
0x00010000-0x00030000 -> 0xC0000000-0xC0030000 (kernel)
0x00030000-0x00040000 -> 0x00030000-0x00040000 (stack)
0x00040000-0x00050000 -> 0x00040000-0x00050000 (ramdisk)
0x000A0000-0x004A0000 -> 0xC1000000-0xC1400000 (kernel data)

which requires an initial mapping of the form: 

0x00000000-0x00400000 -> 0x00000000-0x00400000 (So the current code survives)
0x00010000-0x00410000 -> 0xC0000000-0xC0400000 (kernel)
0x000A0000-0x004A0000 -> 0xC1000000-0xC1400000 (kernel data)
[t_vidmem]-end vidmem -> [t_vidmem]-end vidmem (vidmem)

So we shall give this a go when we've had some sleep, just so we remember to
change all #define lines in ramdisk.c, kernel.c, paging.c, and stage2.asm,
etc.  

22:052512

20091222:140355:RAM Moving

Seems like everything works, but if we put the kernel data as starting at
0xA0000 the data seems to get overwritten with 1s even just after we stick
data there.  Presumably some device lives there and we are disturbin its
slumber.  Or something.  So we put it at 0x100000, and now everything seems to
work as before, except that the ramdisk still thinks it lives at 0x20000.
...Ah, forgot to change what was passed to the kernel in kinit.asm.

So, for future reference, our current mappings are 

Kernel mapping: 

vidmem is idmapped                             (vidmem)
0x00010000-0x00030000 -> 0xC0000000-0xC0030000 (kernel)
0x00030000-0x00040000 -> 0x00030000-0x00040000 (stack)
0x00040000-0x00050000 -> 0x00040000-0x00050000 (ramdisk)
0x00100000-0x00500000 -> 0xC1000000-0xC1400000 (kernel data)

Init mapping (in stage2): 

0x00000000-0x00400000 -> 0x00000000-0x00400000 (So the current code survives)
0x00010000-0x00410000 -> 0xC0000000-0xC0400000 (kernel)
0x00100000-0x00500000 -> 0xC1000000-0xC1400000 (kernel data)
[t_vidmem]-end vidmem -> [t_vidmem]-end vidmem (vidmem)

And success!

141420


20091223:233710:Allocator Testing

The kheap utilizes the physmem allocator quite a bit, and seems to work
decently, so we'll just need to test kheap.  

After realizing that expand populated the descriptors slightly incorrectly,
allocating appears to work.  

And indeed, after realizing that get_block_info is called as

  get_block_info(heap, block_start, &info);

and not as 

  get_block_info(heap, &info, block_start);

free seems to work as well.  YAY!

24:001636

20091224:011755:Things to Allocate

So, having a working allocator (should test whether slabs behave as well as
blocks appear to, but this will come), we can now get on to implementing the
three primitives we had decided on: nodes, events, and connections.  We handle
each in its turn, which should take place in that order.  

The interfaces and such for these has been discussed many times elsewhere, so
we summarize here: 

node: 
  create_node
  dump_node
  switch_to_node

connection: 
  connect
  disconnect
  send
  recv

event: 
  make_event
  dump_event
  fire

020313


20091226:201255:Reworking Paging

Because we are going to be dealing with nodes in our working with tasking, it
would be nice if most of our paging functions worked with pagedirs via nodes,
and with pagedir structs that coincide with what we want to be working with
later on, rather than the rather specific thing they deal in now.  

And after a brief terrifying series of triple faults resulting from zeroing
structs after setting them up, it seems we have success.  

201951

20091227:015300:Physical and Vitrual Allocators' Interactions

There was a problem introduced some time back in which the naive method of
sitting the physical allocator on top of the virtual allocator could fail,
albeit less obviously than the notion might indicate.  However, there is a
solution that now seems rather obvious that allows us to, modulo a little
hack, do exactly what we wanted.  

The problem comes when the virtual memory manager may, in the process of
filling a request stemming from a request to the physical allocator, need to
issue a further request to the physical allocator (e.g. to make another page
table), which will spawn another request to the virtual allocator, and around
and around it goes.  However, if we pre-allocate all tables for all of kernel
space (0xC0000000 onwards) in the kernel's pagedir, mapping them to a
pre-defined range of addresses in kernel space.  This will cost some chunk of
physical RAM, namely 0x1000*0x300 = 0x300000 = 3MB of RAM.  This could be a
serious problem if we ever need to run on systems with, say, 16MB of RAM, but
the complexity and time savings make it worthwhile.  

We can do all this in paging_init, and our mappings will be nicely duplicated
along with the rest of the kernel directory whenever we make a new node, so
the overhead is O(1), usefully.  

Neatly, with the work we've done thus far, this is as easy as 

  u32 i;
  for(i = 0x300; i < 0x400; i++) get_page(i*0x400000, 1, kernel_node->pagedir);

024400


20100628:142613:Reboot, plus ...Toppings!

We have until 20100704 to get something done, so it's time to reboot!

First, the current problem is to setup multitasking (essentially, more
fiddling with paging code), and then to get IPC working.  

However, because kernels are uninteresting, functionally, it does to mention
what we look to place on top of the kernel structure at the end of the day.  

The broad idea is the admittedly hackneyed `Separate form from function'.
This sort of thing is readily accomplished in the web-app world, where the
split of XML/XSLT for content and CSS for form works wonderfully.  However the
much cooler `rich' desktop applications have no such canonical method for
achieving this separation.  Indeed, while OOP methods might provide some help,
it is questionable whether there is any real method at all.  And the point is
not just to satisfy some astronaut's notional aesthetic, but to provide--and
apologies for another buzzword--interoperability.  

There is one place on your computer that you can get any reasonable kind of
interoperability between programs--the shell.  You can take your 800 photos of
your cute little kitty, scale them all down, email the first 30 to a friend,
email only even-numbered ones to your mom, set them all into a webpage, and
set a video of said kitten to play in 10 hours when you plan on waking up, all
without having to pray that some UI-dsigner will have thought to allow you to
do some of these things.  

This is only possible because of programs like ImageMagick's convert, and
mailx, and sed, and programs that provide an interface through the shell.
However, suppose you were not a fan of ImageMagick's shrinking algorithm and
wanted instead to use Photoshop's.  Photoshop is one of those `rich' apps, so
you are unceremoniously dumped back into the days of drag-and-dropping 800
files, waiting while it loads them up, displays all of them (even though you
don't care to see them particularly right now), and then 800 times navigating
a fiddly series of triply-nested menus to get to the effect you want, at which
point you are feeling a bit like a computer yourself for all the mind-numbing
repetetiveness.  

Sure, there might be keyboard shortcuts to make each iteration faster.  There
might even be a custom scripting-language embedded somewhere deep in the
help-files that just might have been done sensibly enough to allow you to do
exactly what you want.  But the shortcuts are just a band-aid, and let's face
it--writing a programming language is hard, and it is unreasonable to ask that
every developer team everywhere understand syntax trees (not least because
learning 50 proprietary scripting languages is not a particularly exciting
prospect), so the second solution isn't really satisfactory either.  

This issue is what we circumvent by separating form from function in rich
apps, but only if we do so in a consistent way (as per the XML/CSS pair,
rather than the application-specific ways achieved by the many OOP solutions,
which, let's face it, are mere architectural niceties).

What we propose is first of all, the obvious: Split off--that is, make a
separate entity (e.g. a separate file)--the functional part of the
application.  The shrinking and blurring and skewing code in Photoshop would
now act merely on byte arrays (or whatever) without worrying about displaying
the result.  Indeed, the code for displaying the result wouldn't even be in
the same binary (And, for that matter, if I had my way, wouldn't be in the
binary at all).  

So our picture so far is: 

                   -------
                   | GUI |
                   -------
----------------
| PS Functions |
----------------   ---------
                   | Shell |
                   ---------


But wait!  We want to actually use that code!  What good is it locked up alone
in some cold, dark, lonely binary?  Right, so we need a way of talking to
it--of calling the functions stored in there.  Well, when the application is
loaded, we can talk to it via IPC, so the functions in the program should all
be callable via IPC.  

But wait!  You can't just tell me that the functions are `somehow' accessible.
You've got to tell me how to access them!  Right, but it depends on how you
want to access them.  I think we've made a reasonable case that, at some
point, you'll want to use a shell, but submit that GUIs have their uses.  Some
people want to be able to control their computers through speech or brainwaves
or magic packets.  So, we need to think of each possible interface that we
care to support--shell, GUI, brainwaves, network.  Say we start with the
shell.  So we need to describe to the shell in a way it understands (e.g. an
XML-formatted interface descriptor, formatted in a way defined by the shell),
the functions available in the package and how to call them.  For instance,
say we have the (pseudocode) program: 

function doStuff(String str){
   print "Look at me "$str"!  I\'m doing stuff!";
   return -78;
}

function doOtherStuff(String str, int i){
   print "My name is "$str" and I am "$i" years old!";
}

function recv(int[] msg){
   int sender_pid = msg[0];
   int func = msg[1];
   if(func == 52){
      send(doStuff((char *)msg[2]), sender_pid);
   }
   else if(func == 101){
      send(doOtherStuff((char *)(msg[2]), (int)(msg[3])), sender_pid);
   }
}

And the interface descriptor: 

stuff_bash.idf

<node path="/usr/bin/stuff">
   <function>
      <name>hello</name>
      <arg name="myname">String</arg>
      <msg>52,./myname</msg>
   </function>
   <function>
      <name>who</name>
      <arg name="arg1">String</arg>
      <arg name="age">int</arg>
      <msg>101,./arg1,./age</msg>
   </function>
</node>

Then we could be in the special shell that understands this format and go: 

$ import stuff
$ funcs stuff
hello
who
$ hello mommy
Look at me mommy!  I\'m doing stuff!
$ who Adrian 12
My name is Adrian and I am 12 years old!
$ 

Fine and dandy, but what about a GUI?  Just as easy.  You just need a GUI that
understands some sort of similarly formatted thing.  For instance: 

stuff_GUI.idf

<target name="myshell" version="1.1" />
<node path="/usr/bin/stuff">
   <panel layout=flow>
      <textfield name="myname" size="400x100" />
      <textfield name="myage" allowed="0123456789" size="200x100" />
      <textfield name="password" echo="*" size="500x100" />
      <button size="200x100" text="Hello!">
         <click>52,(../myname/text)</click>
      </button>
      <button size="200x100" text="Whee!">
         <click>101,(../myname/text),(int)(../myage/text)</click>
      </button>
</node>

Possibly allowing some kind of XPath-aware Javascript-flavoured language into
the mix may be needed to achieve sufficient power, but either way.

So we get the picture: 


                   --------------     -------
               |===|stuff_GUI.id|=====| GUI |
               |   --------------     -------
----------------
| PS Functions |
----------------   ----------------   -------
               |===|stuff_shell.id|===|shell|
                   ----------------   -------


Then, at worst, if you were given a useful program whose programmer neglected
to include an idf compatable with your favourite shell, then you'd still be
able to see what are the messages used and could send the appropriate messages
directly from your shell (assuming it has direct IPC functionality).  

And if you wanted to create a new sort of interface altogether, you could
support pre-existing programs by batch-converting an appropriately informative
existing id file into the id format your interface understands (as there
should be protections to prevent idf-sharing, lest we get nasty descriptor
files containing information for two different interfaces, which would be
obnoxious).

Also, today is perfect-day!

Additionally, this solves an actual problem as well--that of distributing rich
applications: If we believe the idf format is safe to run anywhere, then we
note that for standard webpage `applications', this is all there is to it
anyways.  In some cases the functionality binary (or script or whatever) can
be stored and run server-side, with only the interface being given to the
cleint, and the advantages (in distributability, etc.) of web-apps are
recovered.

160853


20100629:194904:Multitasking!

Now we review the plan for implementing multitasking.  

We essentially need four functions: 

init_tasking()
switch_node(node_t *target_node)
load_node()
dump_node(node_t *to_dump)

init_tasking: 

We have heaps (as discussed before) for four different structures: 

-stacks (which will officially be in the kernel's band of memory but whose
individual pages will likely be assigned as userspace)
-pagedirs
-pagetables
-nodes

So the init_tasking function will simply initialize these heaps and be done.  

dump_node: 

The dump_node function is rather simple, as all it needs do (at the moment) is
to free the node's entry from the node heap (as well as all its
pagedirs/pagetables/stacks from the appropriate other heaps).  When we have
connections floating around this will also need to clean these up.  

load_node: 

This will only need to allocate space for a node, take a pagedir (with the
kernel's bit copied in), get some pagetables and copy in to the appropriate
slot the executable, set eip as needed, and add to the queue of ready tasks.

switch_node: 

This is a bit tricky.  We'll give a detailed outline of this later.  

30:165517


20100630:Tasking and IPC!

Code for tasking is done (not much to it actually).  Will go through it with
the qemu-comb shortly, the structure of the IPC system bears mention now as
the multitasking system depends on it somewhat.  

In the large, the idea is that all IPC will be done through persistent
`connection' primitives, with the idea that the user may want to, for
instance, intercept all keyboard input to a certain program, which would then
be possible by splicing into the connection between the keyboard and program
nodes (we use this model as opposed to the on-the-fly `send to this port'
model for similar reasons to choosing `write to this file-descriptor' over
`write to this path'; the example of bash output redirects show that syntactic
sugar can make this equally painless to the simpler model, programmingwise).

However, because they are also handy, we would like the separate primitive of
events also to be provided by the kernel.  Then associated to each connection
is a `recv' event that the target end of the connection can choose to listen
for (i.e. register a callback for) if it doesn't want to poll the connection
for whether it has sent something, or if it would rather poll, it can not
register and make use of a check_message_queue function, or similar.

Then there is the issue of implementation.  As this is quite
processor-dependent, we can for now just do the naive thing of throwing around
frames of memory on demand.

0702:182217


